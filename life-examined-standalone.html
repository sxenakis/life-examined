<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Life Examined</title>
  <!-- Tailwind (CDN) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Ethers v6 UMD (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.13.2/dist/ethers.umd.min.js"></script>
  <!-- MetaMask eth-sig-util UMD (CDN) provides window.ethSigUtil -->
  <script src="https://unpkg.com/@metamask/eth-sig-util@6.0.1/dist/index.umd.js"></script>
  <style>
    .break-any { word-break: break-word; overflow-wrap: anywhere; }
  </style>
</head>
<body class="min-h-screen bg-slate-50 text-slate-900">
  <div class="max-w-5xl mx-auto p-4 sm:p-8">
    <header class="flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between">
      <h1 class="text-2xl sm:text-3xl font-bold">Life Examined</h1>
      <div class="flex items-center gap-2">
        <button id="btnConnect" class="px-4 py-2 rounded-2xl bg-indigo-600 text-white font-medium shadow hover:bg-indigo-700">Connect MetaMask</button>
        
      </div>
    </header>

    <section class="mt-4 grid gap-4 sm:grid-cols-3">
      <div class="p-4 bg-white rounded-2xl shadow">
        <div class="text-sm text-slate-500">Account</div>
        <div id="account" class="font-mono text-sm mt-1">—</div>
      </div>
      <div class="p-4 bg-white rounded-2xl shadow">
        <div class="text-sm text-slate-500">Chain</div>
        <div id="chain" class="font-mono text-sm mt-1">—</div>
      </div>
      <div class="p-4 bg-white rounded-2xl shadow">
        <div class="text-sm text-slate-500">Contract</div>
        <div id="contractAddr" class="font-mono text-sm mt-1">—</div>
      </div>
    </section>

    

    <section class="mt-6 p-4 bg-white rounded-2xl shadow">
      <h2 class="text-xl font-semibold mb-3">Self‑check (encrypt → decrypt)</h2>
      <div class="flex items-center gap-2">
        <button id="btnSelfCheck" class="px-4 py-2 rounded-2xl bg-emerald-600 text-white font-medium hover:bg-emerald-700">Run Self‑Check</button>
        <div id="selfCheckMsg" class="text-sm"></div>
      </div>
    </section>

    <section class="mt-6 p-4 bg-white rounded-2xl shadow">
      <h2 class="text-xl font-semibold mb-3">New Entry</h2>
      <form id="entryForm" class="grid gap-3">
        <div class="grid sm:grid-cols-2 gap-3">
          <label class="block"> <span class="text-sm text-slate-600">Title</span>
            <input id="title" class="mt-1 w-full px-3 py-2 rounded-xl border border-slate-300 focus:outline-none focus:ring-2 focus:ring-indigo-500" placeholder="A day in Taipei" />
          </label>
          <label class="block"> <span class="text-sm text-slate-600">Category</span>
            <input id="category" class="mt-1 w-full px-3 py-2 rounded-xl border border-slate-300 focus:outline-none focus:ring-2 focus:ring-indigo-500" placeholder="journal" />
          </label>
        </div>
        <label class="block"> <span class="text-sm text-slate-600">Tags (comma‑separated)</span>
          <input id="tags" class="mt-1 w-full px-3 py-2 rounded-xl border border-slate-300 focus:outline-none focus:ring-2 focus:ring-indigo-500" placeholder="life, reflection" />
        </label>
        <label class="block"> <span class="text-sm text-slate-600">Body</span>
          <textarea id="body" rows="6" class="mt-1 w-full px-3 py-2 rounded-xl border border-slate-300 focus:outline-none focus:ring-2 focus:ring-indigo-500" placeholder="Write your entry here..."></textarea>
        </label>
        <div class="flex items-center gap-2">
          <button id="btnPublish" type="submit" class="px-4 py-2 rounded-2xl bg-indigo-600 text-white font-medium hover:bg-indigo-700">Publish</button>
          <div id="publishMsg" class="text-sm"></div>
        </div>
      </form>
    </section>

    <section class="mt-6 p-4 bg-white rounded-2xl shadow">
      <div class="flex items-center justify-between gap-3 flex-wrap">
        <h2 class="text-xl font-semibold">My Entries</h2>
        <div class="text-sm">You have <span id="count">0</span> entries</div>
      </div>
      <div class="mt-3 flex flex-wrap items-end gap-3">
        <label class="block"> <span class="text-xs text-slate-500">Scan from block (deploy block)</span>
          <input id="fromBlock"$1 readonly aria-readonly="true" title="Locked to deploy block for faster scans">
        </label>
        <label class="block"> <span class="text-xs text-slate-500">Chunk size (blocks)</span>
          <input id="chunkSize" type="number" class="mt-1 w-40 px-3 py-2 rounded-xl border border-slate-300" value="50000" />
        </label>
        <div class="flex items-center gap-2">
          <button id="btnRefresh" class="px-4 py-2 rounded-2xl bg-slate-200 hover:bg-slate-300">Refresh List</button>
          
      </div>
      <ol id="entries" class="mt-4 grid gap-3"></ol>
    </section>

    <footer class="mt-10 text-center text-xs text-slate-500">
      No local storage. Everything is from on‑chain events. If decrypt is greyed out, switch to the account that authored the entry.
    </footer>
  </div>

<script>
(() => {
  // ======= CONFIG =======
  const CONTRACT_ADDRESS = "0xE22c571ae8159c44Fe13957Ab18F7c73c674F82A"; // Polygon mainnet address
  const DEPLOY_BLOCK = 73360093; // optional: set your deployment block for faster scans
  const IS_PLACEHOLDER = false; // since address is provided

  const POLYGON_PARAMS = {
    chainId: "0x89",
    chainName: "Polygon Mainnet",
    nativeCurrency: { name: "MATIC", symbol: "MATIC", decimals: 18 },
    rpcUrls: ["https://polygon-rpc.com","https://rpc.ankr.com/polygon","https://polygon-bor-rpc.publicnode.com"],
    blockExplorerUrls: ["https://polygonscan.com"]
  };

  // ABI
  const ABI = [
    {"inputs":[],"name":"getMyCount","outputs":[{"internalType":"uint64","name":"","type":"uint64"}],"stateMutability":"view","type":"function"},
    {"inputs":[{"internalType":"string","name":"cipherJson","type":"string"},{"internalType":"uint64","name":"timestamp","type":"uint64"},{"internalType":"string","name":"titleHint","type":"string"}],"name":"appendEntry","outputs":[],"stateMutability":"nonpayable","type":"function"},
    {"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"author","type":"address"},{"indexed":true,"internalType":"uint64","name":"idx","type":"uint64"},{"indexed":false,"internalType":"uint64","name":"timestamp","type":"uint64"},{"indexed":false,"internalType":"string","name":"cipherJson","type":"string"},{"indexed":false,"internalType":"string","name":"titleHint","type":"string"}],"name":"EntryAppended","type":"event"}
  ];

  // ======= STATE =======
  const $ = (s)=>document.querySelector(s);
  const ui = { btnConnect:$('#btnConnect'), btnSwitch:$('#btnSwitch'), account:$('#account'), chain:$('#chain'), contractAddr:$('#contractAddr'), btnSelfCheck:$('#btnSelfCheck'), selfCheckMsg:$('#selfCheckMsg'), form:$('#entryForm'), title:$('#title'), category:$('#category'), tags:$('#tags'), body:$('#body'), publishMsg:$('#publishMsg'), count:$('#count'), entries:$('#entries'), btnRefresh:$('#btnRefresh'), btnExportJSON:$('#btnExportJSON'), btnExportCSV:$('#btnExportCSV'), fromBlock:$('#fromBlock'), chunkSize:$('#chunkSize') };
  let provider, signer, contract, account, chainIdHex, iface; let cachedEvents=[];

  function setStatus(el,msg,ok=true){ el.textContent=msg; el.className = ok ? 'text-sm text-emerald-700' : 'text-sm text-rose-700'; }
  function shortAddr(a){ return a? a.slice(0,6)+'…'+a.slice(-4) : '—'; }
  function updateBtnStates(){
    const connectedState = !!connected;
    ui.btnConnect.textContent = connectedState ? 'Connected' : 'Connect MetaMask';
    ui.btnConnect.disabled = connectedState;
    const onPolygon = chainIdHex === '0x89';
    if (ui.btnSwitch) { ui.btnSwitch.disabled = onPolygon; ui.btnSwitch?.classList?.toggle('opacity-60', onPolygon); }
    ui.contractAddr.textContent = CONTRACT_ADDRESS || '—';
  }

  async function ensureProvider(){ if(!window.ethereum) throw new Error('MetaMask not detected.'); provider = new ethers.BrowserProvider(window.ethereum); return provider; }
  async function refreshChainAccountUI(){
    if (!provider) return;
    const net=await provider.getNetwork();
    chainIdHex='0x'+net.chainId.toString(16);
    const name= chainIdHex==='0x89'?'Polygon Mainnet':(net.name||'Unknown');
    ui.chain.textContent=`${name} (${chainIdHex})`;
    const accts = connected ? await provider.listAccounts() : [];
    account = accts[0]?.address;
    ui.account.textContent = account || '—';
    updateBtnStates();
  } (${chainIdHex})`; const accts=await provider.listAccounts(); account=accts[0]?.address; ui.account.textContent=account||'—'; updateBtnStates(); }

  async function connect(){
    await ensureProvider();
    // Explicit permission request; will prompt MetaMask if not already connected/locked
    await window.ethereum.request({method:'eth_requestAccounts'});
    connected = true;
    await refreshChainAccountUI();
    signer = await provider.getSigner();
    iface = new ethers.Interface(ABI);
    contract = new ethers.Contract(CONTRACT_ADDRESS, ABI, signer);
    if (chainIdHex !== '0x89') setStatus(ui.selfCheckMsg,'Connected, but not on Polygon. Please switch.', false);
    await refreshCount();
    // Set listeners only after connection
    if (window.ethereum && !window.__le_listeners) {
      window.__le_listeners = true;
      window.ethereum.on('accountsChanged', async ()=>{ if(!provider) return; await refreshChainAccountUI(); await refreshCount(); await refreshList(); });
      window.ethereum.on('chainChanged', async ()=>{ if(!provider) return; await refreshChainAccountUI(); await refreshCount(); await refreshList(); });
    }
  }); await refreshChainAccountUI(); signer=await provider.getSigner(); iface=new ethers.Interface(ABI); contract=new ethers.Contract(CONTRACT_ADDRESS, ABI, signer); if(chainIdHex!=='0x89'){ setStatus(ui.selfCheckMsg,'Connected, but not on Polygon. Click "Switch to Polygon".', false);} await refreshCount(); }
  async function switchToPolygon(){ await ensureProvider(); try{ await window.ethereum.request({method:'wallet_switchEthereumChain', params:[{chainId:'0x89'}]}); }catch(err){ if(err.code===4902 || /not added/i.test(err.message||'')){ await window.ethereum.request({method:'wallet_addEthereumChain', params:[POLYGON_PARAMS]}); } else { throw err; } } await refreshChainAccountUI(); }

  async function ensureSigUtil(){
    let sig = window.ethSigUtil || window.EthSigUtil || window.SigUtil || window.metamaskEthSigUtil;
    if (sig && sig.encrypt) return sig;
    const urls = [
      'https://cdn.jsdelivr.net/npm/@metamask/eth-sig-util@6.0.1/dist/index.umd.js',
      'https://unpkg.com/@metamask/eth-sig-util@6.0.1/dist/index.umd.js'
    ];
    for (const src of urls){
      await new Promise((resolve)=>{
        const s=document.createElement('script'); s.src=src; s.onload=()=>resolve(); s.onerror=()=>resolve(); document.head.appendChild(s);
      });
      sig = window.ethSigUtil || window.EthSigUtil || window.SigUtil || window.metamaskEthSigUtil;
      if (sig && sig.encrypt) return sig;
    }
    throw new Error('eth-sig-util UMD not loaded.');
  }
  async function encryptForAccount(addr,dataObj){
    const sig = await ensureSigUtil();
    const publicKey = await window.ethereum.request({method:'eth_getEncryptionPublicKey', params:[addr]});
    const cipher = sig.encrypt({ publicKey, data: JSON.stringify(dataObj), version:'x25519-xsalsa20-poly1305'});
    return JSON.stringify(cipher);
  });
    const cipher = sig.encrypt({ publicKey, data: JSON.stringify(dataObj), version:'x25519-xsalsa20-poly1305'});
    return JSON.stringify(cipher);
  });
    } catch (e) {
      if (e && (e.code === -32601 || /method not found/i.test(e.message||''))) {
        throw new Error('MetaMask does not expose eth_getEncryptionPublicKey in this context. Make sure you are using MetaMask (not another provider), are on a https origin, and your account is selected.');
      }
      throw e;
    }
    const cipher = encryptFn({ publicKey, data: JSON.stringify(dataObj), version:'x25519-xsalsa20-poly1305' });
    return JSON.stringify(cipher);
  }).then((publicKey)=>{
      const cipher = SigUtil.encrypt({ publicKey, data: JSON.stringify(dataObj), version:'x25519-xsalsa20-poly1305' });
      return JSON.stringify(cipher);
    });
  }); const cipher = window.ethSigUtil.encrypt({ publicKey, data: JSON.stringify(dataObj), version:'x25519-xsalsa20-poly1305'}); return JSON.stringify(cipher); }
  async function decryptForAccount(addr,cipherJson){
    try {
      return await window.ethereum.request({method:'eth_decrypt', params:[cipherJson, addr]});
    } catch (e) {
      if (e && (e.code === -32601 || /method not found/i.test(e.message||''))) {
        throw new Error('MetaMask does not expose eth_decrypt in this context. Use MetaMask on a https origin and ensure the same account that encrypted is selected.');
      }
      throw e;
    }
  }); }

  async function runSelfCheck(){
    try{
      if(!account) throw new Error('Connect first.');
      // Quick provider sanity: must be MetaMask and have request
      if (!window.ethereum || typeof window.ethereum.request !== 'function') {
        throw new Error('No EIP‑1193 provider. Install MetaMask.');
      }
      const cipherJson = await encryptForAccount(account,{hello:'world'});
      const plain = await decryptForAccount(account,cipherJson);
      const obj=JSON.parse(plain);
      if(obj.hello==='world') setStatus(ui.selfCheckMsg,'Self‑check passed.');
      else setStatus(ui.selfCheckMsg,'Self‑check failed: mismatch.', false);
    } catch(e){
      const msg = (e && e.message) ? e.message : String(e);
      if(/Requested account and message do not match/i.test(msg)) {
        setStatus(ui.selfCheckMsg,`Decrypt blocked. Switch MetaMask to ${shortAddr(account)}.`, false);
      } else if(/eth_getEncryptionPublicKey|eth_decrypt/.test(msg)){
        setStatus(ui.selfCheckMsg, msg, false);
      } else {
        setStatus(ui.selfCheckMsg, `Self‑check error: ${msg}`, false);
      }
    }
  });
      const plain = await decryptForAccount(account,cipherJson);
      const obj=JSON.parse(plain);
      if(obj.hello==='world') setStatus(ui.selfCheckMsg,'Self‑check passed.');
      else setStatus(ui.selfCheckMsg,'Self‑check failed: mismatch.', false);
    } catch(e){
      const msg = (e && e.message) ? e.message : String(e);
      if(/Requested account and message do not match/i.test(msg)) setStatus(ui.selfCheckMsg,`Decrypt blocked. Switch MetaMask to ${shortAddr(account)}.`, false);
      else if(/eth_getEncryptionPublicKey/i.test(msg) && /does not exist|not supported|not available/i.test(msg)) setStatus(ui.selfCheckMsg,'Your MetaMask does not expose eth_getEncryptionPublicKey. Update MetaMask or enable encryption permissions for this account.', false);
      else setStatus(ui.selfCheckMsg,`Self‑check error: ${msg}`, false);
    }
  }); const plain = await decryptForAccount(account,cipherJson); const obj=JSON.parse(plain); if(obj.hello==='world') setStatus(ui.selfCheckMsg,'Self‑check passed.'); else setStatus(ui.selfCheckMsg,'Self‑check failed: mismatch.', false);} catch(e){ if(/Requested account and message do not match/.test(e.message||'')) setStatus(ui.selfCheckMsg,`Decrypt blocked. Switch MetaMask to ${shortAddr(account)}.`, false); else setStatus(ui.selfCheckMsg,`Self‑check error: ${e.message}`, false); } }

  function nowSec(){ return Math.floor(Date.now()/1000); } function nowMs(){ return Date.now(); }

  async function publish(e){ e.preventDefault(); try{ if(!account) throw new Error('Connect first.'); if(chainIdHex!=='0x89') throw new Error('Switch to Polygon before publishing.'); if(!contract) throw new Error('Contract not initialized.'); const title=ui.title.value.trim(); const body=ui.body.value.trim(); const category=ui.category.value.trim()||'journal'; const tags=ui.tags.value.split(',').map(s=>s.trim()).filter(Boolean); if(!title||!body) throw new Error('Title and body are required.'); const payload={version:1, enc:'metamask-v2', ts:nowMs(), title, body, category, tags}; const cipherJson = await encryptForAccount(account, payload); setStatus(ui.publishMsg,'Encrypted. Sending tx…'); const tx = await contract.appendEntry(cipherJson, BigInt(nowSec()), 'Encrypted Entry'); setStatus(ui.publishMsg,`Submitted ${tx.hash}. Waiting…`); const rc = await tx.wait(); setStatus(ui.publishMsg,`Confirmed in block ${rc.blockNumber}.`, true); await refreshCount(); await refreshList(); ui.body.value=''; } catch(e){ setStatus(ui.publishMsg,`Publish failed: ${e.message}`, false); } }

  async function refreshCount(){ if(!account) { ui.count.textContent='0'; return; } try{ const n = await (contract||new ethers.Contract(CONTRACT_ADDRESS, ABI, await provider.getSigner())).getMyCount(); ui.count.textContent = (typeof n==='bigint')? Number(n).toString(): n.toString(); } catch{ ui.count.textContent='—'; }
  }

  async function refreshList(){ if(!account){ ui.entries.innerHTML=''; return; } ui.entries.innerHTML=''; cachedEvents=[]; const start = DEPLOY_BLOCK; const chunk = Math.max(1000, parseInt(ui.chunkSize.value||'50000',10)); const latest = await provider.getBlockNumber(); const ifaceLocal = new ethers.Interface(ABI); const topic0 = ifaceLocal.getEventTopic('EntryAppended'); const authorTopic = ethers.zeroPadValue(account,32); let from = isNaN(start)?0:Math.max(0,start); let to = Math.min(latest, from + chunk - 1); const wanted = parseInt(ui.count.textContent||'0',10);
    while(from <= latest){ try{ const logs = await provider.getLogs({ address: CONTRACT_ADDRESS, fromBlock: from, toBlock: to, topics: [topic0, authorTopic] }); for(const log of logs){ const parsed = ifaceLocal.parseLog(log); const {author, idx, timestamp, cipherJson, titleHint} = parsed.args; cachedEvents.push({ blockNumber: log.blockNumber, logIndex: log.index, author, idx:Number(idx), timestamp:Number(timestamp), cipherJson, titleHint }); } if(wanted && cachedEvents.length >= wanted) break; } catch(e){ console.warn('getLogs failed', from, to, e); } from = to + 1; to = Math.min(latest, from + chunk - 1); }
    cachedEvents.sort((a,b)=> a.blockNumber - b.blockNumber || a.logIndex - b.logIndex);
    if(cachedEvents.length===0){ ui.entries.innerHTML='<li class="text-sm text-slate-500">No entries found in scanned range.</li>'; return; }
    for(const ev of cachedEvents){ const li=document.createElement('li'); li.className='p-4 bg-slate-50 border border-slate-200 rounded-2xl'; const dt=new Date(ev.timestamp*1000); li.innerHTML=`<div class=\"flex items-center justify-between gap-3 flex-wrap\"><div class=\"font-medium\">#${ev.idx} • ${ev.titleHint||'Encrypted Entry'}</div><div class=\"text-xs text-slate-500\">block ${ev.blockNumber} • ${dt.toLocaleString()}</div></div><details class=\"mt-2 group\"><summary class=\"cursor-pointer select-none text-sm text-indigo-700\">Encrypted payload (cipherJson)</summary><pre class=\"mt-2 text-xs break-any\">${escapeHtml(ev.cipherJson)}</pre></details><div class=\"mt-3 flex items-center gap-2\"><button class=\"px-3 py-1.5 rounded-xl bg-emerald-600 text-white text-sm hover:bg-emerald-700\" data-action=\"decrypt\">Decrypt</button><span class=\"text-xs text-slate-500\">(one MetaMask prompt)</span></div><div class=\"mt-2 text-sm\" data-output></div>`; li.querySelector('[data-action="decrypt"]').addEventListener('click',()=>decryptEntry(ev,li)); ui.entries.appendChild(li);} }

  async function decryptEntry(ev,container){ const out=container.querySelector('[data-output]'); out.textContent='Decrypting…'; try{ const plain = await decryptForAccount(account, ev.cipherJson); const obj = JSON.parse(plain); out.innerHTML = renderPlain(obj);} catch(e){ if(/account and message do not match/i.test(e.message||'')) out.innerHTML = `<span class="text-rose-700">Switch MetaMask to ${account} (the author) to decrypt.</span>`; else if(/User denied/.test(e.message||'')) out.innerHTML = `<span class="text-slate-600">Decrypt cancelled.</span>`; else out.innerHTML = `<span class="text-rose-700">Decrypt failed: ${escapeHtml(e.message)}</span>`; } }

  function renderPlain(obj){ const tags = Array.isArray(obj.tags)? obj.tags.join(', '):''; const t=new Date(obj.ts||Date.now()).toLocaleString(); return `<div class=\"p-3 bg-white border border-slate-200 rounded-xl\"><div class=\"text-sm text-slate-500\">${t}</div><div class=\"font-semibold\">${escapeHtml(obj.title||'')}</div><div class=\"mt-1 whitespace-pre-wrap\">${escapeHtml(obj.body||'')}</div><div class=\"mt-2 text-xs text-slate-500\">Category: ${escapeHtml(obj.category||'')}${tags? ' • Tags: '+escapeHtml(tags):''}</div></div>`; }
  function escapeHtml(s){ return (s||'').toString().replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/\"/g,'&quot;').replace(/'/g,'&#39;'); }
  function exportJSON(){ const data=cachedEvents.map(e=>({idx:e.idx,timestamp:e.timestamp,blockNumber:e.blockNumber,cipherJson:e.cipherJson})); const blob=new Blob([JSON.stringify(data,null,2)],{type:'application/json'}); const url=URL.createObjectURL(blob); triggerDownload(url,'life-examined-events.json'); }
  function exportCSV(){ const rows=[["idx","timestamp","blockNumber","cipherJson"]].concat(cachedEvents.map(e=>[e.idx,e.timestamp,e.blockNumber,e.cipherJson.replaceAll('"','""')])); const csv=rows.map(r=>r.map(v=>`"${String(v)}"`).join(',')).join('\n'); const blob=new Blob([csv],{type:'text/csv'}); const url=URL.createObjectURL(blob); triggerDownload(url,'life-examined-events.csv'); }
  function triggerDownload(url,filename){ const a=document.createElement('a'); a.href=url; a.download=filename; a.click(); setTimeout(()=>URL.revokeObjectURL(url),5000); }

  ui.btnConnect.addEventListener('click', connect);
  // removed Switch button per user request
  ui.btnSelfCheck.addEventListener('click', runSelfCheck);
  ui.form.addEventListener('submit', publish);
  ui.btnRefresh.addEventListener('click', (e)=>{ e.preventDefault(); refreshList(); });
  // removed export buttons exportJSON(); });
  // removed export buttons exportCSV(); });

  // listeners now attached after explicit connect() only); window.ethereum.on('chainChanged', async ()=>{ if(!provider) return; await refreshChainAccountUI(); await refreshCount(); await refreshList(); }); }

  ui.contractAddr.textContent = CONTRACT_ADDRESS || '—';
  ui.fromBlock.value = String(DEPLOY_BLOCK || 0);
  updateBtnStates();
})();
</script>
</body>
</html>
