<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Life Examined - Blockchain Journal</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/web3/1.8.0/web3.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .line-clamp-2 {
            overflow: hidden;
            display: -webkit-box;
            -webkit-box-orient: vertical;
            -webkit-line-clamp: 2;
        }
        .tag-input {
            min-height: 40px;
            padding: 8px;
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            align-items: center;
        }
        .tag-chip {
            background: #3b82f6;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .tag-chip button {
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            padding: 0;
            margin-left: 4px;
        }
    </style>
</head>
<body>
    <div id="app">
        <div class="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 flex items-center justify-center p-4">
            <div class="bg-white rounded-2xl shadow-xl p-8 max-w-md w-full text-center">
                <div class="mb-6">
                    <h1 class="text-3xl font-bold text-gray-900 mb-6">Life Examined</h1>
                </div>
                
                <button
                    id="connectButton"
                    class="w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-4 rounded-lg transition-colors hover:shadow-lg"
                >
                    Connect MetaMask to Polygon
                </button>
                
                <div id="status" class="mt-4 text-sm text-gray-600"></div>
            </div>
        </div>
    </div>

    <script>
        const CONTRACT_ADDRESS = '0xE22c571ae8159c44Fe13957Ab18F7c73c674F82A';
        const CONTRACT_ABI = [
            {
                "inputs": [
                    {"internalType": "string", "name": "_ipfsHash", "type": "string"},
                    {"internalType": "uint256", "name": "_timestamp", "type": "uint256"},
                    {"internalType": "string", "name": "_title", "type": "string"}
                ],
                "name": "storeEntry",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "getMyEntries",
                "outputs": [
                    {
                        "components": [
                            {"internalType": "string", "name": "ipfsHash", "type": "string"},
                            {"internalType": "uint256", "name": "_timestamp", "type": "uint256"},
                            {"internalType": "string", "name": "title", "type": "string"},
                            {"internalType": "address", "name": "author", "type": "address"}
                        ],
                        "internalType": "struct LifeExamined.Entry[]",
                        "name": "",
                        "type": "tuple[]"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "totalEntries",
                "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            }
        ];

        // Predefined categories with emojis
        const PREDEFINED_CATEGORIES = [
            { name: 'Personal', emoji: '👤', color: 'bg-blue-100 text-blue-800' },
            { name: 'Work', emoji: '💼', color: 'bg-green-100 text-green-800' },
            { name: 'Relationships', emoji: '❤️', color: 'bg-pink-100 text-pink-800' },
            { name: 'Goals', emoji: '🎯', color: 'bg-purple-100 text-purple-800' },
            { name: 'Health', emoji: '🏥', color: 'bg-red-100 text-red-800' },
            { name: 'Travel', emoji: '✈️', color: 'bg-yellow-100 text-yellow-800' },
            { name: 'Learning', emoji: '📚', color: 'bg-indigo-100 text-indigo-800' },
            { name: 'Gratitude', emoji: '🙏', color: 'bg-green-100 text-green-800' },
            { name: 'Reflection', emoji: '🤔', color: 'bg-gray-100 text-gray-800' },
            { name: 'Ideas', emoji: '💡', color: 'bg-yellow-100 text-yellow-800' }
        ];

        let state = {
            entries: [],
            currentEntry: '',
            currentTitle: '',
            currentCategory: '',
            currentTags: [],
            selectedEntry: null,
            isConnected: false,
            walletAddress: '',
            searchTerm: '',
            selectedCategoryFilter: '',
            selectedTagFilter: '',
            isUploading: false,
            web3: null,
            contract: null,
            encryptionCache: new Map(),
            allTags: new Set(),
            tagInput: ''
        };

        function updateStatus(message) {
            const statusDiv = document.getElementById('status');
            if (statusDiv) {
                statusDiv.textContent = message;
                console.log(message);
            }
        }

        function checkMetaMask() {
            if (typeof window.ethereum === 'undefined') {
                updateStatus('MetaMask not detected. Please install MetaMask.');
                return false;
            }
            updateStatus('MetaMask detected!');
            return true;
        }

        function addTag(tag) {
            if (tag && !state.currentTags.includes(tag)) {
                state.currentTags.push(tag);
                state.allTags.add(tag);
                updateTagsDisplay();
                updateSaveButton();
            }
        }

        function removeTag(tag) {
            state.currentTags = state.currentTags.filter(t => t !== tag);
            updateTagsDisplay();
            updateSaveButton();
        }

        function updateTagsDisplay() {
            const tagContainer = document.getElementById('tagContainer');
            if (!tagContainer) return;

            tagContainer.innerHTML = '';
            
            state.currentTags.forEach(tag => {
                const tagChip = document.createElement('span');
                tagChip.className = 'tag-chip';
                tagChip.innerHTML = `${tag} <button onclick="removeTag('${tag}')">×</button>`;
                tagContainer.appendChild(tagChip);
            });

            // Add input for new tags
            const tagInputElement = document.createElement('input');
            tagInputElement.id = 'tagInputField';
            tagInputElement.type = 'text';
            tagInputElement.placeholder = state.currentTags.length === 0 ? 'Add tags...' : '';
            tagInputElement.className = 'border-none outline-none flex-1 min-w-[100px]';
            tagInputElement.value = state.tagInput;
            
            tagInputElement.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ',') {
                    e.preventDefault();
                    const tag = e.target.value.trim();
                    if (tag) {
                        addTag(tag);
                        e.target.value = '';
                        state.tagInput = '';
                    }
                }
            });
            
            tagInputElement.addEventListener('input', (e) => {
                state.tagInput = e.target.value;
            });
            
            tagContainer.appendChild(tagInputElement);
        }

        async function uploadToIPFS(encryptedData) {
            try {
                const ipfsData = {
                    encryptedTitle: encryptedData.encryptedTitle,
                    encryptedContent: encryptedData.encryptedContent,
                    encryptedCategory: encryptedData.encryptedCategory,
                    encryptedTags: encryptedData.encryptedTags,
                    timestamp: new Date().toISOString(),
                    signature: encryptedData.signature,
                    message: encryptedData.message,
                    author: state.walletAddress,
                    version: "2.0"
                };

                console.log('Uploading to IPFS...');
                const mockHash = 'Qm' + Array.from({length: 44}, () => 
                    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'[
                        Math.floor(Math.random() * 62)
                    ]
                ).join('');
                
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                return {
                    IpfsHash: mockHash,
                    PinSize: JSON.stringify(ipfsData).length,
                    Timestamp: new Date().toISOString()
                };

            } catch (error) {
                console.error('IPFS upload failed:', error);
                throw error;
            }
        }

        async function encryptEntry(content, title, category, tags) {
            try {
                let signature;
                let message = 'Encrypt journal entry: ' + Date.now();
                
                if (typeof window.ethereum !== 'undefined' && state.isConnected) {
                    try {
                        signature = await window.ethereum.request({
                            method: 'personal_sign',
                            params: [message, state.walletAddress],
                        });
                        console.log('✅ Got real signature for encryption');
                    } catch (signError) {
                        console.log('Signature failed, using fallback:', signError);
                        signature = '0x' + Array.from({length: 130}, () => 
                            Math.floor(Math.random() * 16).toString(16)
                        ).join('');
                    }
                } else {
                    signature = '0x' + Array.from({length: 130}, () => 
                        Math.floor(Math.random() * 16).toString(16)
                    ).join('');
                }
                
                const keyData = signature.slice(2, 66);
                
                const encryptText = (text, key) => {
                    let result = '';
                    for (let i = 0; i < text.length; i++) {
                        result += String.fromCharCode(text.charCodeAt(i) ^ key.charCodeAt(i % key.length));
                    }
                    return btoa(result);
                };
                
                const encryptedTitle = encryptText(title, keyData);
                const encryptedContent = encryptText(content, keyData);
                const encryptedCategory = encryptText(category, keyData);
                const encryptedTags = encryptText(JSON.stringify(tags), keyData);
                
                const entryKey = title + '_' + Date.now();
                state.encryptionCache.set(entryKey, { signature, message });
                
                return {
                    encryptedTitle,
                    encryptedContent,
                    encryptedCategory,
                    encryptedTags,
                    signature,
                    message,
                    entryKey
                };
            } catch (error) {
                console.error('Encryption failed:', error);
                throw error;
            }
        }

        function decryptEntry(encryptedData, providedSignature = null) {
            try {
                const signature = providedSignature || encryptedData.signature;
                if (!signature) {
                    throw new Error('No signature available for decryption');
                }
                
                const keyData = signature.slice(2, 66);
                
                const decryptText = (encryptedText, key) => {
                    try {
                        const decoded = atob(encryptedText);
                        let result = '';
                        for (let i = 0; i < decoded.length; i++) {
                            result += String.fromCharCode(decoded.charCodeAt(i) ^ key.charCodeAt(i % key.length));
                        }
                        return result;
                    } catch (error) {
                        console.error('Decryption error:', error);
                        return '[Decryption Error]';
                    }
                };
                
                const decryptedTitle = decryptText(encryptedData.encryptedTitle, keyData);
                const decryptedContent = decryptText(encryptedData.encryptedContent, keyData);
                
                // Handle backward compatibility - older entries may not have category/tags
                let decryptedCategory = '';
                let decryptedTags = [];
                
                try {
                    if (encryptedData.encryptedCategory) {
                        decryptedCategory = decryptText(encryptedData.encryptedCategory, keyData);
                    }
                } catch (error) {
                    console.log('No category data (older entry)');
                    decryptedCategory = '';
                }
                
                try {
                    if (encryptedData.encryptedTags) {
                        const tagsString = decryptText(encryptedData.encryptedTags, keyData);
                        decryptedTags = JSON.parse(tagsString || '[]');
                    }
                } catch (error) {
                    console.log('No tags data (older entry)');
                    decryptedTags = [];
                }
                
                return {
                    title: decryptedTitle,
                    content: decryptedContent,
                    category: decryptedCategory,
                    tags: decryptedTags,
                    success: true
                };
            } catch (error) {
                console.error('Decryption failed:', error);
                return { 
                    title: '[Decryption Error]', 
                    content: '[Unable to decrypt entry - may need to re-sign with your wallet]',
                    category: '',
                    tags: [],
                    success: false
                };
            }
        }

        async function retrieveAndDecryptFromIPFS(ipfsHash, originalTitle) {
            try {
                console.log('Retrieving content from IPFS for hash:', ipfsHash);
                
                const ipfsUrl = 'https://gateway.pinata.cloud/ipfs/' + ipfsHash;
                
                try {
                    const response = await fetch(ipfsUrl);
                    if (response.ok) {
                        const ipfsData = await response.json();
                        console.log('Retrieved data from IPFS:', ipfsData);
                        
                        let decrypted = decryptEntry(ipfsData);
                        
                        if (!decrypted.success) {
                            console.log('Decryption failed, may need fresh signature');
                            return {
                                title: originalTitle,
                                content: 'This entry is encrypted. Click "Decrypt Entry" below to decrypt it with your wallet signature.',
                                category: '',
                                tags: [],
                                isDecrypted: false,
                                canRetryDecryption: true,
                                ipfsData: ipfsData
                            };
                        }
                        
                        // Add tags to global set
                        if (decrypted.tags && Array.isArray(decrypted.tags)) {
                            decrypted.tags.forEach(tag => state.allTags.add(tag));
                        }
                        
                        return {
                            title: decrypted.title || originalTitle,
                            content: decrypted.content,
                            category: decrypted.category || '',
                            tags: Array.isArray(decrypted.tags) ? decrypted.tags : [],
                            isDecrypted: true,
                            ipfsData: ipfsData
                        };
                    }
                } catch (ipfsError) {
                    console.log('IPFS retrieval failed (expected for demo):', ipfsError);
                }
                
                // Fallback for demo - provide default values for older entries
                return {
                    title: originalTitle,
                    content: 'This entry would show your decrypted journal content here.\n\nThe actual content is encrypted and stored on IPFS at: ' + ipfsHash + '\n\nIn a production version, this would retrieve and decrypt your actual journal text using your private key.',
                    category: 'Personal', // Default category for older entries
                    tags: ['legacy'], // Default tag for older entries
                    isDecrypted: false,
                    note: 'Demo mode - actual IPFS retrieval would happen in production'
                };
                
            } catch (error) {
                console.error('Error retrieving from IPFS:', error);
                return {
                    title: originalTitle,
                    content: 'Error retrieving content from IPFS: ' + error.message,
                    category: '',
                    tags: [],
                    isDecrypted: false
                };
            }
        }

        async function decryptEntryWithFreshSignature(entry) {
            try {
                if (!state.isConnected || !entry.ipfsData) {
                    throw new Error('Wallet not connected or no IPFS data available');
                }

                const message = 'Decrypt journal entry: ' + Date.now();
                const signature = await window.ethereum.request({
                    method: 'personal_sign',
                    params: [message, state.walletAddress],
                });

                console.log('Got fresh signature for decryption');

                const decrypted = decryptEntry(entry.ipfsData, signature);
                
                if (decrypted.success) {
                    // Add tags to global set (with safety check)
                    if (decrypted.tags && Array.isArray(decrypted.tags)) {
                        decrypted.tags.forEach(tag => state.allTags.add(tag));
                    }
                    
                    const entryIndex = state.entries.findIndex(e => e.id === entry.id);
                    if (entryIndex !== -1) {
                        state.entries[entryIndex] = {
                            ...state.entries[entryIndex],
                            title: decrypted.title,
                            content: decrypted.content,
                            category: decrypted.category || '',
                            tags: Array.isArray(decrypted.tags) ? decrypted.tags : [],
                            isDecrypted: true
                        };
                        
                        if (state.selectedEntry && state.selectedEntry.id === entry.id) {
                            state.selectedEntry = state.entries[entryIndex];
                        }
                    }
                    
                    updateEntriesDisplay();
                    updateFilters();
                    if (state.selectedEntry) {
                        showEntryModal();
                    }
                    
                    return {
                        success: true,
                        title: decrypted.title,
                        content: decrypted.content,
                        category: decrypted.category || '',
                        tags: Array.isArray(decrypted.tags) ? decrypted.tags : []
                    };
                } else {
                    throw new Error('Decryption failed even with fresh signature');
                }

            } catch (error) {
                console.error('Fresh decryption failed:', error);
                if (error.code === 4001) {
                    alert('Decryption cancelled by user');
                } else {
                    alert('Failed to decrypt entry: ' + error.message);
                }
                return { success: false };
            }
        }

        async function storeOnBlockchain(ipfsHash, title, timestamp) {
            try {
                if (!state.contract || !state.isConnected) {
                    throw new Error('Wallet not connected or contract not initialized');
                }

                console.log('Preparing blockchain transaction...');

                try {
                    const totalEntries = await state.contract.methods.totalEntries().call();
                    console.log('Contract is accessible. Current total entries:', totalEntries);
                } catch (readError) {
                    console.error('Contract read test failed:', readError);
                    throw new Error('Cannot communicate with smart contract');
                }

                let gasEstimate;
                try {
                    gasEstimate = await state.contract.methods.storeEntry(
                        ipfsHash,
                        timestamp,
                        title
                    ).estimateGas({ from: state.walletAddress });
                    
                    console.log('Gas estimate:', gasEstimate);
                } catch (estimateError) {
                    console.error('Gas estimation failed:', estimateError);
                    gasEstimate = 300000;
                    console.log('Using default gas limit:', gasEstimate);
                }

                const gasPrice = await state.web3.eth.getGasPrice();
                const gasLimit = Math.floor(gasEstimate * 1.2);

                console.log('Sending blockchain transaction...');
                const tx = await state.contract.methods.storeEntry(
                    ipfsHash,
                    timestamp,
                    title
                ).send({
                    from: state.walletAddress,
                    gas: gasLimit,
                    gasPrice: gasPrice
                });
                
                console.log('✅ Real blockchain transaction successful!');
                console.log('Transaction Hash:', tx.transactionHash);
                
                return tx.transactionHash;
                
            } catch (error) {
                console.error('Blockchain transaction failed:', error);
                
                if (error.message.includes('revert')) {
                    throw new Error('Smart contract rejected the transaction. Please check your parameters.');
                } else if (error.message.includes('insufficient funds')) {
                    throw new Error('Insufficient POL for gas fees. Please add more POL to your wallet.');
                } else if (error.code === 4001) {
                    throw new Error('Transaction was cancelled by user.');
                } else {
                    throw new Error('Transaction failed: ' + error.message);
                }
            }
        }

        async function connectWallet() {
            updateStatus('Checking MetaMask...');
            
            if (!checkMetaMask()) {
                return;
            }

            try {
                updateStatus('Requesting account access...');
                const accounts = await window.ethereum.request({ 
                    method: 'eth_requestAccounts' 
                });
                
                if (accounts.length > 0) {
                    updateStatus('Checking network...');
                    
                    const chainId = await window.ethereum.request({ method: 'eth_chainId' });
                    
                    if (chainId !== '0x89') {
                        updateStatus('Switching to Polygon network...');
                        try {
                            await window.ethereum.request({
                                method: 'wallet_switchEthereumChain',
                                params: [{ chainId: '0x89' }],
                            });
                        } catch (switchError) {
                            if (switchError.code === 4902) {
                                updateStatus('Adding Polygon network...');
                                await window.ethereum.request({
                                    method: 'wallet_addEthereumChain',
                                    params: [{
                                        chainId: '0x89',
                                        chainName: 'Polygon Mainnet',
                                        nativeCurrency: {
                                            name: 'POL',
                                            symbol: 'POL',
                                            decimals: 18,
                                        },
                                        rpcUrls: ['https://polygon-rpc.com/'],
                                        blockExplorerUrls: ['https://polygonscan.com/'],
                                    }],
                                });
                            }
                        }
                    }
                    
                    updateStatus('Initializing Web3...');
                    state.web3 = new Web3(window.ethereum);
                    state.contract = new state.web3.eth.Contract(CONTRACT_ABI, CONTRACT_ADDRESS);
                    state.walletAddress = accounts[0];
                    state.isConnected = true;
                    
                    updateStatus('Testing contract connection...');
                    try {
                        const totalEntries = await state.contract.methods.totalEntries().call();
                        console.log('Contract connection successful. Total entries:', totalEntries);
                        updateStatus('Connected successfully!');
                    } catch (contractError) {
                        console.error('Contract connection test failed:', contractError);
                        updateStatus('Warning: Contract may not be accessible');
                    }
                    
                    console.log('✅ Connected to Polygon with real MetaMask!');
                    
                    await loadEntries();
                    renderMainApp();
                    
                    window.ethereum.on('accountsChanged', (accounts) => {
                        if (accounts.length === 0) {
                            state.isConnected = false;
                            state.walletAddress = '';
                            renderWelcomeScreen();
                        } else {
                            state.walletAddress = accounts[0];
                            loadEntries();
                            renderMainApp();
                        }
                    });
                }
            } catch (error) {
                console.error('Error connecting to MetaMask:', error);
                updateStatus('Connection failed: ' + error.message);
            }
        }

        async function loadEntries() {
            try {
                if (state.contract && state.isConnected) {
                    console.log('Loading entries from blockchain...');
                    
                    try {
                        const blockchainEntries = await state.contract.methods.getMyEntries().call({
                            from: state.walletAddress
                        });
                        
                        console.log('Raw blockchain entries:', blockchainEntries);
                        
                        if (blockchainEntries && blockchainEntries.length > 0) {
                            const processedEntries = await Promise.all(
                                blockchainEntries.map(async (entry, index) => {
                                    let displayTitle = entry.title || ('Entry ' + new Date(entry.timestamp * 1000).toLocaleDateString());
                                    let displayContent = 'Encrypted entry stored on IPFS: ' + entry.ipfsHash;
                                    let displayCategory = '';
                                    let displayTags = [];
                                    let isDecrypted = false;
                                    let ipfsData = null;
                                    let canRetryDecryption = false;
                                    
                                    try {
                                        const decryptedData = await retrieveAndDecryptFromIPFS(entry.ipfsHash, displayTitle);
                                        displayTitle = decryptedData.title;
                                        displayContent = decryptedData.content;
                                        displayCategory = decryptedData.category;
                                        displayTags = decryptedData.tags;
                                        isDecrypted = decryptedData.isDecrypted;
                                        ipfsData = decryptedData.ipfsData;
                                        canRetryDecryption = decryptedData.canRetryDecryption;
                                    } catch (decryptError) {
                                        console.log('Could not decrypt entry:', decryptError);
                                    }

                                    // Safe timestamp conversion
                                    let entryTimestamp;
                                    try {
                                        // Handle both seconds and milliseconds timestamps
                                        let timestampMs = entry.timestamp;
                                        if (timestampMs < 1000000000000) { // If timestamp is in seconds
                                            timestampMs = timestampMs * 1000;
                                        }
                                        entryTimestamp = new Date(timestampMs).toISOString();
                                        
                                        // Validate the timestamp
                                        if (entryTimestamp === 'Invalid Date' || isNaN(new Date(timestampMs).getTime())) {
                                            throw new Error('Invalid timestamp: ' + entry.timestamp);
                                        }
                                    } catch (timestampError) {
                                        console.warn('Invalid timestamp detected:', entry.timestamp, timestampError);
                                        // Use current time as fallback
                                        entryTimestamp = new Date().toISOString();
                                    }

                                    return {
                                        id: (entry.timestamp || Date.now()) * 1000 + index, // Use timestamp in milliseconds for unique ID
                                        title: displayTitle,
                                        content: displayContent,
                                        category: displayCategory,
                                        tags: displayTags,
                                        timestamp: entryTimestamp,
                                        encrypted: true,
                                        onChain: true,
                                        ipfsHash: entry.ipfsHash,
                                        txHash: 'On blockchain',
                                        originalEntry: entry,
                                        isDecrypted: isDecrypted,
                                        ipfsData: ipfsData,
                                        canRetryDecryption: canRetryDecryption
                                    };
                                })
                            );
                            
                            state.entries = processedEntries.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                            console.log('✅ Loaded and processed ' + state.entries.length + ' entries from blockchain');
                            
                            if (state.entries.length === 0) {
                                console.log('⚠️ Contract returned entries but processing resulted in empty list');
                            }
                        } else {
                            console.log('No entries found on blockchain for this wallet');
                            state.entries = [];
                        }
                    } catch (blockchainError) {
                        console.error('Failed to load from blockchain:', blockchainError);
                        
                        if (blockchainError.message.includes('revert')) {
                            console.log('Contract call reverted - might be no entries or contract issue');
                        } else if (blockchainError.message.includes('network')) {
                            console.log('Network error - blockchain might be slow');
                        }
                        
                        state.entries = [];
                    }
                } else {
                    console.log('Contract not ready - will load entries after connection');
                    state.entries = [];
                }
            } catch (error) {
                console.error('Error loading entries:', error);
                state.entries = [];
            }
        }

        async function saveEntry() {
            if (!state.currentTitle.trim() || !state.currentEntry.trim()) {
                alert('Please enter both a title and content for your journal entry.');
                return;
            }
            
            state.isUploading = true;
            renderMainApp();
            
            try {
                console.log('Step 1: Encrypting entry...');
                const encryptedData = await encryptEntry(
                    state.currentEntry, 
                    state.currentTitle, 
                    state.currentCategory,
                    state.currentTags
                );
                
                console.log('Step 2: Uploading to IPFS...');
                const ipfsResult = await uploadToIPFS(encryptedData);
                
                console.log('Step 3: Storing on blockchain...');
                const txHash = await storeOnBlockchain(
                    ipfsResult.IpfsHash, 
                    state.currentTitle, 
                    Math.floor(Date.now() / 1000)
                );
                
                console.log('Step 4: Creating entry record...');
                
                // Add tags to global set
                state.currentTags.forEach(tag => state.allTags.add(tag));
                
                const newEntry = {
                    id: Date.now(),
                    title: state.currentTitle,
                    content: state.currentEntry,
                    category: state.currentCategory,
                    tags: [...state.currentTags],
                    timestamp: new Date().toISOString(),
                    encrypted: true,
                    onChain: true,
                    ipfsHash: ipfsResult.IpfsHash,
                    ipfsSize: ipfsResult.PinSize,
                    txHash: txHash,
                    isDecrypted: true
                };
                
                // Add to entries immediately (optimistic update)
                state.entries.unshift(newEntry);
                
                // Clear form
                state.currentEntry = '';
                state.currentTitle = '';
                state.currentCategory = '';
                state.currentTags = [];
                state.tagInput = '';
                
                console.log('✅ Entry complete! Encrypted → IPFS → Blockchain');
                console.log('🎉 Your journal entry is now completely decentralized!');
                console.log('Transaction Hash:', txHash);
                
                alert('🎉 Journal entry successfully saved to blockchain!\n\nTransaction: ' + txHash);
                
                // Wait a moment for blockchain confirmation, then reload entries
                setTimeout(async () => {
                    console.log('Reloading entries from blockchain to confirm...');
                    await loadEntries();
                    updateEntriesDisplay();
                    updateFilters();
                }, 5000); // Wait 5 seconds for blockchain confirmation
                
            } catch (error) {
                console.error('Failed to save entry:', error);
                alert('Failed to save entry: ' + error.message);
                
                // Remove the optimistic entry if save failed
                state.entries = state.entries.filter(entry => entry.id !== Date.now());
            } finally {
                state.isUploading = false;
                renderMainApp();
                updateFilters();
            }
        }

        function viewEntry(entryId) {
            const entry = state.entries.find(e => e.id == entryId);
            if (entry) {
                state.selectedEntry = entry;
                showEntryModal();
            }
        }

        function getCategoryInfo(categoryName) {
            return PREDEFINED_CATEGORIES.find(cat => cat.name === categoryName) || 
                   { name: categoryName, emoji: '📝', color: 'bg-gray-100 text-gray-800' };
        }

        function showEntryModal() {
            if (!state.selectedEntry) return;

            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50';
            
            const modalContent = document.createElement('div');
            modalContent.className = 'bg-white rounded-2xl shadow-xl max-w-2xl w-full max-h-[80vh] overflow-y-auto';
            
            const modalInner = document.createElement('div');
            modalInner.className = 'p-6';
            
            const isDecrypted = state.selectedEntry.isDecrypted;
            const canRetryDecryption = state.selectedEntry.canRetryDecryption;
            
            let statusContent = '';
            let actionButtons = '';
            
            if (isDecrypted) {
                statusContent = '<div class="bg-green-50 border border-green-200 rounded-lg p-4 mb-4">' +
                    '<p class="text-sm text-green-800">' +
                        '<strong>✅ Decrypted:</strong> This entry has been successfully decrypted using your private key.' +
                    '</p>' +
                '</div>';
            } else if (canRetryDecryption) {
                statusContent = '<div class="bg-yellow-50 border border-yellow-200 rounded-lg p-4 mb-4">' +
                    '<p class="text-sm text-yellow-800">' +
                        '<strong>🔒 Encrypted:</strong> This entry is encrypted. Click the button below to decrypt it with your wallet signature.' +
                    '</p>' +
                '</div>';
                actionButtons = '<button onclick="decryptCurrentEntry()" class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-lg transition-colors mr-2">🔓 Decrypt Entry</button>';
            } else {
                statusContent = '<div class="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-4">' +
                    '<p class="text-sm text-blue-800">' +
                        '<strong>Note:</strong> This entry is encrypted and stored on IPFS. ' +
                        'In a production environment, this would be automatically decrypted.' +
                    '</p>' +
                '</div>';
            }

            // Category display
            const categoryInfo = getCategoryInfo(state.selectedEntry.category);
            const categoryDisplay = state.selectedEntry.category ? 
                `<div class="flex items-center space-x-1">
                    <span>${categoryInfo.emoji}</span>
                    <span class="px-2 py-1 rounded-full text-xs font-medium ${categoryInfo.color}">${state.selectedEntry.category}</span>
                </div>` : '';

            // Tags display
            const tagsDisplay = state.selectedEntry.tags && state.selectedEntry.tags.length > 0 ? 
                `<div class="flex flex-wrap gap-1">
                    ${state.selectedEntry.tags.map(tag => 
                        `<span class="px-2 py-1 bg-blue-100 text-blue-800 text-xs rounded-full">#${tag}</span>`
                    ).join('')}
                </div>` : '';
            
            modalInner.innerHTML = 
                '<div class="flex items-center justify-between mb-4">' +
                    '<h2 class="text-2xl font-bold text-gray-900">' + state.selectedEntry.title + '</h2>' +
                    '<button onclick="closeEntryModal()" class="text-gray-400 hover:text-gray-600 text-xl">✕</button>' +
                '</div>' +
                '<div class="flex flex-wrap items-center gap-4 mb-4 text-sm text-gray-600">' +
                    '<div class="flex items-center space-x-1">' +
                        '<span>📅</span>' +
                        '<span>' + new Date(state.selectedEntry.timestamp).toLocaleString() + '</span>' +
                    '</div>' +
                    '<div class="flex items-center space-x-1">' +
                        '<span>🔒</span>' +
                        '<span>' + (isDecrypted ? 'Decrypted' : 'Encrypted') + '</span>' +
                    '</div>' +
                    '<div class="flex items-center space-x-1">' +
                        '<span>⛓️</span>' +
                        '<span>On Blockchain</span>' +
                    '</div>' +
                '</div>' +
                (categoryDisplay ? '<div class="mb-4">' + categoryDisplay + '</div>' : '') +
                (tagsDisplay ? '<div class="mb-4">' + tagsDisplay + '</div>' : '') +
                '<div class="prose max-w-none">' +
                    statusContent +
                    '<div class="bg-gray-50 border border-gray-200 rounded-lg p-4">' +
                        '<p class="whitespace-pre-wrap text-gray-700 leading-relaxed">' + state.selectedEntry.content + '</p>' +
                    '</div>' +
                '</div>' +
                '<div class="mt-6 flex items-center space-x-2">' +
                    actionButtons +
                    '<button onclick="closeEntryModal()" class="bg-gray-500 hover:bg-gray-600 text-white font-semibold py-2 px-4 rounded-lg transition-colors">Close</button>' +
                '</div>' +
                '<div class="mt-6 pt-4 border-t border-gray-200">' +
                    '<div class="text-xs text-gray-500 space-y-1">' +
                        '<div><strong>IPFS Hash:</strong> ' + state.selectedEntry.ipfsHash + '</div>' +
                        '<div><strong>Transaction:</strong> ' + state.selectedEntry.txHash + '</div>' +
                        '<div><strong>Entry Size:</strong> ' + (state.selectedEntry.ipfsSize || 'Unknown') + ' bytes</div>' +
                    '</div>' +
                '</div>';

            modalContent.appendChild(modalInner);
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
        }

        window.decryptCurrentEntry = async function() {
            if (state.selectedEntry) {
                const result = await decryptEntryWithFreshSignature(state.selectedEntry);
                if (result.success) {
                    showEntryModal();
                }
            }
        };

        function closeEntryModal() {
            const modal = document.querySelector('.fixed.inset-0.bg-black.bg-opacity-50');
            if (modal) {
                modal.remove();
                state.selectedEntry = null;
            }
        }

        function updateFilters() {
            const categoryFilter = document.getElementById('categoryFilter');
            const tagFilter = document.getElementById('tagFilter');
            
            if (categoryFilter) {
                const categories = [...new Set(state.entries.map(e => e.category).filter(c => c))];
                categoryFilter.innerHTML = '<option value="">All Categories</option>' +
                    categories.map(cat => `<option value="${cat}" ${cat === state.selectedCategoryFilter ? 'selected' : ''}>${cat}</option>`).join('');
            }
            
            if (tagFilter) {
                const tags = Array.from(state.allTags);
                tagFilter.innerHTML = '<option value="">All Tags</option>' +
                    tags.map(tag => `<option value="${tag}" ${tag === state.selectedTagFilter ? 'selected' : ''}>#${tag}</option>`).join('');
            }
        }

        function renderWelcomeScreen() {
            const app = document.getElementById('app');
            app.innerHTML = '';
            
            const container = document.createElement('div');
            container.className = 'min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 flex items-center justify-center p-4';
            
            const card = document.createElement('div');
            card.className = 'bg-white rounded-2xl shadow-xl p-8 max-w-md w-full text-center';
            
            const header = document.createElement('div');
            header.className = 'mb-6';
            
            const title = document.createElement('h1');
            title.className = 'text-3xl font-bold text-gray-900 mb-6';
            title.textContent = 'Life Examined';
            
            const button = document.createElement('button');
            button.id = 'connectButton';
            button.className = 'w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-4 rounded-lg transition-colors hover:shadow-lg';
            button.textContent = 'Connect MetaMask to Polygon';
            button.addEventListener('click', connectWallet);
            
            const status = document.createElement('div');
            status.id = 'status';
            status.className = 'mt-4 text-sm text-gray-600';
            
            header.appendChild(title);
            card.appendChild(header);
            card.appendChild(button);
            card.appendChild(status);
            container.appendChild(card);
            app.appendChild(container);
        }

        function renderMainApp() {
            const app = document.getElementById('app');
            app.innerHTML = '';

            const mainContainer = document.createElement('div');
            mainContainer.className = 'min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100';

            // Header
            const header = document.createElement('header');
            header.className = 'bg-white shadow-sm border-b';
            
            const headerContent = document.createElement('div');
            headerContent.className = 'max-w-7xl mx-auto px-4 sm:px-6 lg:px-8';
            
            const headerInner = document.createElement('div');
            headerInner.className = 'flex justify-between items-center py-4';
            
            const titleDiv = document.createElement('div');
            titleDiv.className = 'flex items-center space-x-3';
            
            const headerTitle = document.createElement('h1');
            headerTitle.className = 'text-2xl font-bold text-gray-900';
            headerTitle.textContent = 'Life Examined';
            
            const statusDiv = document.createElement('div');
            statusDiv.className = 'flex items-center space-x-4';
            
            const walletInfo = document.createElement('div');
            walletInfo.className = 'text-sm text-gray-600';
            walletInfo.textContent = 'Connected: ' + state.walletAddress.slice(0, 6) + '...' + state.walletAddress.slice(-4);
            
            const connectionStatus = document.createElement('div');
            connectionStatus.className = 'flex items-center space-x-1 text-green-600 text-sm';
            connectionStatus.innerHTML = '<div class="w-2 h-2 bg-green-500 rounded-full"></div><span>Polygon Connected</span>';
            
            titleDiv.appendChild(headerTitle);
            statusDiv.appendChild(walletInfo);
            statusDiv.appendChild(connectionStatus);
            headerInner.appendChild(titleDiv);
            headerInner.appendChild(statusDiv);
            headerContent.appendChild(headerInner);
            header.appendChild(headerContent);

            // Main content
            const mainContent = document.createElement('div');
            mainContent.className = 'max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8';
            
            const grid = document.createElement('div');
            grid.className = 'grid grid-cols-1 lg:grid-cols-3 gap-8';

            // New entry section
            const newEntrySection = document.createElement('div');
            newEntrySection.className = 'lg:col-span-2';
            
            const newEntryCard = document.createElement('div');
            newEntryCard.className = 'bg-white rounded-2xl shadow-lg p-6';
            
            const newEntryHeader = document.createElement('div');
            newEntryHeader.className = 'flex items-center justify-between mb-6';
            newEntryHeader.innerHTML = '<h2 class="text-xl font-semibold text-gray-900">New Entry</h2><div class="flex items-center space-x-2 text-sm text-gray-500"><span>🔒 Encrypted before blockchain</span></div>';
            
            const formDiv = document.createElement('div');
            formDiv.className = 'space-y-4';
            
            const titleInput = document.createElement('input');
            titleInput.type = 'text';
            titleInput.id = 'titleInput';
            titleInput.placeholder = 'Entry title...';
            titleInput.value = state.currentTitle;
            titleInput.className = 'w-full px-4 py-3 border border-gray-200 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent';
            titleInput.addEventListener('input', (e) => {
                state.currentTitle = e.target.value;
                updateSaveButton();
            });

            // Category selector
            const categoryDiv = document.createElement('div');
            categoryDiv.innerHTML = '<label class="block text-sm font-medium text-gray-700 mb-2">Category</label>';
            
            const categorySelect = document.createElement('select');
            categorySelect.id = 'categorySelect';
            categorySelect.className = 'w-full px-4 py-3 border border-gray-200 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent';
            categorySelect.innerHTML = '<option value="">Select a category...</option>' +
                PREDEFINED_CATEGORIES.map(cat => 
                    `<option value="${cat.name}" ${cat.name === state.currentCategory ? 'selected' : ''}>${cat.emoji} ${cat.name}</option>`
                ).join('');
            categorySelect.addEventListener('change', (e) => {
                state.currentCategory = e.target.value;
                updateSaveButton();
            });
            
            categoryDiv.appendChild(categorySelect);

            // Tags input
            const tagsDiv = document.createElement('div');
            tagsDiv.innerHTML = '<label class="block text-sm font-medium text-gray-700 mb-2">Tags</label>';
            
            const tagContainer = document.createElement('div');
            tagContainer.id = 'tagContainer';
            tagContainer.className = 'tag-input';
            
            tagsDiv.appendChild(tagContainer);
            
            const contentInput = document.createElement('textarea');
            contentInput.id = 'contentInput';
            contentInput.placeholder = 'Write your thoughts here... Everything you write will be encrypted and stored on Polygon blockchain.';
            contentInput.rows = 10;
            contentInput.value = state.currentEntry;
            contentInput.className = 'w-full px-4 py-3 border border-gray-200 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent resize-none';
            contentInput.addEventListener('input', (e) => {
                state.currentEntry = e.target.value;
                updateSaveButton();
            });
            
            const saveButton = document.createElement('button');
            saveButton.id = 'saveButton';
            saveButton.className = 'flex items-center space-x-2 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-300 text-white font-semibold py-3 px-6 rounded-lg transition-colors';
            const buttonText = state.isUploading ? 'Encrypting → IPFS → Blockchain...' : 'Save to Blockchain';
            saveButton.innerHTML = '<span>➕</span><span>' + buttonText + '</span>';
            saveButton.addEventListener('click', saveEntry);
            
            formDiv.appendChild(titleInput);
            formDiv.appendChild(categoryDiv);
            formDiv.appendChild(tagsDiv);
            formDiv.appendChild(contentInput);
            formDiv.appendChild(saveButton);
            newEntryCard.appendChild(newEntryHeader);
            newEntryCard.appendChild(formDiv);
            newEntrySection.appendChild(newEntryCard);

            // Entries section
            const entriesSection = document.createElement('div');
            entriesSection.className = 'lg:col-span-1';
            
            const entriesCard = document.createElement('div');
            entriesCard.className = 'bg-white rounded-2xl shadow-lg p-6';
            
            const entriesHeader = document.createElement('div');
            entriesHeader.className = 'flex items-center justify-between mb-4';
            entriesHeader.innerHTML = '<h2 class="text-xl font-semibold text-gray-900">Your Entries</h2><span>📖</span>';
            
            // Filters section
            const filtersDiv = document.createElement('div');
            filtersDiv.className = 'space-y-3 mb-4';
            
            const searchInput = document.createElement('input');
            searchInput.type = 'text';
            searchInput.id = 'searchInput';
            searchInput.placeholder = 'Search entries...';
            searchInput.value = state.searchTerm;
            searchInput.className = 'w-full px-3 py-2 border border-gray-200 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-sm';
            searchInput.addEventListener('input', (e) => {
                state.searchTerm = e.target.value;
                updateEntriesDisplay();
            });

            const categoryFilter = document.createElement('select');
            categoryFilter.id = 'categoryFilter';
            categoryFilter.className = 'w-full px-3 py-2 border border-gray-200 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-sm';
            categoryFilter.addEventListener('change', (e) => {
                state.selectedCategoryFilter = e.target.value;
                updateEntriesDisplay();
            });

            const tagFilter = document.createElement('select');
            tagFilter.id = 'tagFilter';
            tagFilter.className = 'w-full px-3 py-2 border border-gray-200 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-sm';
            tagFilter.addEventListener('change', (e) => {
                state.selectedTagFilter = e.target.value;
                updateEntriesDisplay();
            });
            
            filtersDiv.appendChild(searchInput);
            filtersDiv.appendChild(categoryFilter);
            filtersDiv.appendChild(tagFilter);
            
            const entriesContainer = document.createElement('div');
            entriesContainer.className = 'space-y-3 max-h-96 overflow-y-auto';
            entriesContainer.id = 'entriesContainer';
            
            entriesCard.appendChild(entriesHeader);
            entriesCard.appendChild(filtersDiv);
            entriesCard.appendChild(entriesContainer);
            entriesSection.appendChild(entriesCard);

            grid.appendChild(newEntrySection);
            grid.appendChild(entriesSection);
            mainContent.appendChild(grid);
            mainContainer.appendChild(header);
            mainContainer.appendChild(mainContent);
            app.appendChild(mainContainer);

            updateTagsDisplay();
            updateEntriesDisplay();
            updateFilters();
            updateSaveButton();
        }

        function updateEntriesDisplay() {
            const entriesContainer = document.getElementById('entriesContainer');
            if (!entriesContainer) return;

            let filteredEntries = state.entries.filter(entry => {
                const matchesSearch = !state.searchTerm || 
                    entry.title.toLowerCase().includes(state.searchTerm.toLowerCase()) ||
                    entry.content.toLowerCase().includes(state.searchTerm.toLowerCase()) ||
                    (entry.tags && entry.tags.some(tag => tag.toLowerCase().includes(state.searchTerm.toLowerCase())));
                
                const matchesCategory = !state.selectedCategoryFilter || entry.category === state.selectedCategoryFilter;
                
                const matchesTag = !state.selectedTagFilter || 
                    (entry.tags && entry.tags.includes(state.selectedTagFilter));
                
                return matchesSearch && matchesCategory && matchesTag;
            });

            entriesContainer.innerHTML = '';

            if (filteredEntries.length === 0) {
                const emptyDiv = document.createElement('div');
                emptyDiv.className = 'text-center py-8 text-gray-500';
                let message = 'No entries found.';
                if (state.entries.length === 0) {
                    message = 'No entries yet. Start writing!';
                } else if (state.searchTerm || state.selectedCategoryFilter || state.selectedTagFilter) {
                    message = 'No matching entries found.';
                }
                emptyDiv.innerHTML = '<span class="text-4xl">📖</span><p>' + message + '</p>';
                entriesContainer.appendChild(emptyDiv);
            } else {
                filteredEntries.forEach(entry => {
                    const entryDiv = document.createElement('div');
                    entryDiv.className = 'p-3 border border-gray-200 rounded-lg cursor-pointer hover:bg-gray-50 transition-colors';
                    entryDiv.addEventListener('click', () => viewEntry(entry.id));
                    
                    const statusIcon = entry.isDecrypted ? '🔓' : (entry.canRetryDecryption ? '🔒' : '🔐');
                    const statusColor = entry.isDecrypted ? 'text-green-500' : (entry.canRetryDecryption ? 'text-yellow-500' : 'text-gray-500');
                    
                    const categoryInfo = getCategoryInfo(entry.category);
                    const categoryDisplay = entry.category ? 
                        `<span class="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium ${categoryInfo.color}">${categoryInfo.emoji} ${entry.category}</span>` : '';
                    
                    const tagsDisplay = entry.tags && entry.tags.length > 0 ? 
                        `<div class="flex flex-wrap gap-1 mt-2">
                            ${entry.tags.slice(0, 3).map(tag => 
                                `<span class="px-1.5 py-0.5 bg-blue-100 text-blue-800 text-xs rounded">#${tag}</span>`
                            ).join('')}
                            ${entry.tags.length > 3 ? `<span class="text-xs text-gray-500">+${entry.tags.length - 3}</span>` : ''}
                        </div>` : '';
                    
                    entryDiv.innerHTML = 
                        '<div class="flex items-start justify-between mb-2">' +
                            '<h3 class="font-medium text-gray-900 truncate flex-1 mr-2">' + entry.title + '</h3>' +
                            '<span class="' + statusColor + ' flex-shrink-0">' + statusIcon + '</span>' +
                        '</div>' +
                        (categoryDisplay ? '<div class="mb-2">' + categoryDisplay + '</div>' : '') +
                        '<p class="text-sm text-gray-600 line-clamp-2 mb-2">' + entry.content + '</p>' +
                        tagsDisplay +
                        '<div class="flex items-center justify-between mt-2 text-xs text-gray-500">' +
                            '<span>' + new Date(entry.timestamp).toLocaleDateString() + '</span>' +
                            '<span>IPFS: ' + entry.ipfsHash.slice(0, 6) + '...</span>' +
                        '</div>';
                    
                    entriesContainer.appendChild(entryDiv);
                });
            }
        }

        function updateSaveButton() {
            const saveButton = document.getElementById('saveButton');
            if (saveButton) {
                const isDisabled = !state.currentTitle.trim() || !state.currentEntry.trim() || state.isUploading;
                saveButton.disabled = isDisabled;
                if (isDisabled) {
                    saveButton.classList.add('opacity-50', 'cursor-not-allowed');
                } else {
                    saveButton.classList.remove('opacity-50', 'cursor-not-allowed');
                }
            }
        }

        // Global functions
        window.closeEntryModal = closeEntryModal;
        window.removeTag = removeTag;

        document.addEventListener('DOMContentLoaded', function() {
            console.log('Life Examined app with tags and categories initializing...');
            
            if (checkMetaMask()) {
                updateStatus('MetaMask detected! Click to connect.');
            }
            
            renderWelcomeScreen();
        });
    </script>
</body>
</html>
