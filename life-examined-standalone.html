<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Secure Blockchain Journal</title>
    <script src="https://cdn.jsdelivr.net/npm/buffer@6.0.3/index.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tweetnacl@1.0.3/nacl.min.js"></script>
    <script src="https://unpkg.com/ethers@6.13.1/dist/ethers.umd.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
        textarea { width: 100%; height: 100px; }
        button { margin: 5px; padding: 10px; }
        .entry { border: 1px solid #ccc; margin: 10px 0; padding: 10px; }
        #status { color: green; font-weight: bold; }
    </style>
</head>
<body>
    <h1>My Secure Blockchain Journal</h1>
    <p>Connect your MetaMask wallet to start. Entries are encrypted locally and stored on-chain—only you can read them.</p>

    <button id="connectBtn">Connect Wallet</button>
    <div id="status"></div>

    <h2>Add New Entry</h2>
    <textarea id="entryText" placeholder="Write your journal entry here..."></textarea>
    <br>
    <button id="publishBtn" disabled>Encrypt & Publish (1 Tx)</button>

    <h2>Past Entries</h2>
    <button id="loadBtn" disabled>Load My Entries</button>
    <div id="entriesList"></div>

    <script>
        // Config: Your deployed contract address
        const CONTRACT_ADDRESS = '0xACFD7f4E6e75eEDE3ccd6111adF5CB6eAE69FEf3';
        const CHAIN_ID = 137; // Polygon mainnet

        // Contract ABI (simple interface for our Journal contract)
        const ABI = [
            'event EntryAdded(address indexed author, uint256 indexed entryId, bytes ciphertext)',
            'function addEntry(bytes calldata ciphertext) external',
            'function getCounter(address author) external view returns (uint256)'
        ];

        let provider, signer, contract, userAddress, encryptionPublicKey;
        const statusEl = document.getElementById('status');
        const connectBtn = document.getElementById('connectBtn');
        const publishBtn = document.getElementById('publishBtn');
        const loadBtn = document.getElementById('loadBtn');
        const entriesList = document.getElementById('entriesList');

        // Helper to show status messages
        function updateStatus(msg, isError = false) {
            statusEl.textContent = msg;
            statusEl.style.color = isError ? 'red' : 'green';
        }

        // Pure JS Base58 helpers (no external libs needed)
        const MAP = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
        function to_b58(B) {
            var d = [], s = "", i, j, c, n;
            for (i in B) { j = 0, c = B[i]; s += c || s.length ^ i ? "" : "1"; while (j in d || c) { n = d[j]; n = n ? n * 256 + c : c; c = n / 58 | 0; d[j] = n % 58; j++; } }
            while (j--) s += MAP[d[j]];
            return s;
        }
        function from_b58(S) {
            var d = [], b = [], i, j, c, n;
            for (i in S) { j = 0, c = MAP.indexOf(S[i]); if (c < 0) return undefined; c || b.length ^ i ? i : b.push(0); while (j in d || c) { n = d[j]; n = n ? n * 58 + c : c; c = n >> 8; d[j] = n % 256; j++; } }
            while (j--) b.push(d[j]);
            return new Uint8Array(b);
        }

        // Custom encrypt function (using TweetNaCl for secure math + our Base58 helpers)
        function encrypt(publicKey, data) {
            const messageUint8 = new TextEncoder().encode(data);
            const nonce = nacl.randomBytes(nacl.box.nonceLength);
            const ourEphemeralPK = nacl.box.keyPair();
            const theirPKUint8 = new Uint8Array(Buffer.from(publicKey, 'base64')); // Decode base64 to bytes
            const shared = nacl.box.before(theirPKUint8, ourEphemeralPK.secretKey);
            const encryptedBytes = nacl.box.after(messageUint8, nonce, shared);
            const output = {
                version: 'x25519-xsalsa20-poly1305',
                nonce: to_b58(Array.from(nonce)), // Encode to Base58
                ephemPublicKey: to_b58(Array.from(ourEphemeralPK.publicKey)),
                ciphertext: to_b58(Array.from(encryptedBytes))
            };
            return output;
        }

        // Step 1: Connect wallet (explicit prompt)
        connectBtn.onclick = async () => {
            try {
                if (typeof window.ethereum === 'undefined') {
                    throw new Error('MetaMask not found! Install it.');
                }
                provider = new ethers.BrowserProvider(window.ethereum);
                await provider.send('eth_requestAccounts', []); // Prompts MetaMask
                const network = await provider.getNetwork();
                if (Number(network.chainId) !== CHAIN_ID) {
                    throw new Error(`Switch to Polygon (ID: ${CHAIN_ID}) in MetaMask.`);
                }
                signer = await provider.getSigner();
                userAddress = await signer.getAddress();
                contract = new ethers.Contract(CONTRACT_ADDRESS, ABI, signer);

                // Step 2: Get encryption public key (one-time per session)
                encryptionPublicKey = await provider.send('eth_getEncryptionPublicKey', [userAddress]);

                connectBtn.disabled = true;
                connectBtn.textContent = `Connected: ${userAddress.slice(0, 6)}...`;
                publishBtn.disabled = false;
                loadBtn.disabled = false;
                updateStatus('Wallet connected and encryption key ready!');
            } catch (err) {
                updateStatus(err.message, true);
            }
        };

        // Step 3: Encrypt & Publish (one tx)
        publishBtn.onclick = async () => {
            const text = document.getElementById('entryText').value.trim();
            if (!text) return updateStatus('Enter some text!', true);

            try {
                updateStatus('Encrypting...');
                // Encrypt locally using MetaMask's key (no private key exposed)
                const encrypted = encrypt(encryptionPublicKey, text);
                const ciphertext = '0x' + Buffer.from(JSON.stringify(encrypted), 'utf8').toString('hex');

                updateStatus('Publishing to blockchain...');
                const tx = await contract.addEntry(ciphertext);
                await tx.wait();
                document.getElementById('entryText').value = '';
                updateStatus(`Entry #${await contract.getCounter(userAddress)} published! Tx: ${tx.hash}`);
            } catch (err) {
                updateStatus(err.message, true);
            }
        };

        // Step 4: Load past entries (queries blockchain logs)
        loadBtn.onclick = async () => {
            try {
                updateStatus('Loading entries...');
                const topic0 = ethers.id('EntryAdded(address,uint256,bytes)');
                const topic1 = ethers.zeroPadValue(userAddress, 32); // Filter by your address
                const filter = {
                    fromBlock: 0,
                    toBlock: 'latest',
                    address: CONTRACT_ADDRESS,
                    topics: [topic0, topic1]
                };
                const logs = await provider.getLogs(filter);
                logs.reverse(); // Oldest first by block order

                entriesList.innerHTML = '';
                if (logs.length === 0) {
                    entriesList.innerHTML = '<p>No entries yet.</p>';
                    return;
                }

                logs.forEach((log, index) => {
                    const entryId = BigInt(log.topics[1]).toString();
                    const ciphertext = log.data; // Already hex bytes
                    const entryDiv = document.createElement('div');
                    entryDiv.className = 'entry';
                    entryDiv.innerHTML = `
                        <h3>Entry #${entryId}</h3>
                        <button onclick="decryptEntry('${ciphertext}', ${index})">Decrypt (MetaMask Prompt)</button>
                        <div id="decrypted-${index}"></div>
                    `;
                    entriesList.appendChild(entryDiv);
                });
                updateStatus(`${logs.length} entries loaded!`);
            } catch (err) {
                updateStatus(err.message, true);
            }
        };

        // Step 5: Decrypt on demand (single MetaMask prompt)
        window.decryptEntry = async (ciphertext, index) => {
            try {
                const decrypted = await provider.send('eth_decrypt', [ciphertext, userAddress]);
                document.getElementById(`decrypted-${index}`).innerHTML = `<p><strong>Decrypted:</strong> ${decrypted}</p>`;
            } catch (err) {
                updateStatus('Decryption failed—check MetaMask prompt.', true);
            }
        };
    </script>
</body>
</html>
