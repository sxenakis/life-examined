<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Life Examined - Blockchain Journal</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/web3/1.8.0/web3.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .line-clamp-2 {
            overflow: hidden;
            display: -webkit-box;
            -webkit-box-orient: vertical;
            -webkit-line-clamp: 2;
        }
    </style>
</head>
<body>
    <div id="app">
        <div class="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 flex items-center justify-center p-4">
            <div class="bg-white rounded-2xl shadow-xl p-8 max-w-md w-full text-center">
                <div class="mb-6">
                    <h1 class="text-3xl font-bold text-gray-900 mb-6">Life Examined</h1>
                </div>
                
                <button
                    id="connectButton"
                    class="w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-4 rounded-lg transition-colors hover:shadow-lg"
                >
                    Connect MetaMask to Polygon
                </button>
                
                <div id="status" class="mt-4 text-sm text-gray-600"></div>
            </div>
        </div>
    </div>

    <script>
        const CONTRACT_ADDRESS = '0xE22c571ae8159c44Fe13957Ab18F7c73c674F82A';
        const CONTRACT_ABI = [
            {
                "inputs": [
                    {"internalType": "string", "name": "_ipfsHash", "type": "string"},
                    {"internalType": "uint256", "name": "_timestamp", "type": "uint256"},
                    {"internalType": "string", "name": "_title", "type": "string"}
                ],
                "name": "storeEntry",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "getMyEntries",
                "outputs": [
                    {
                        "components": [
                            {"internalType": "string", "name": "ipfsHash", "type": "string"},
                            {"internalType": "uint256", "name": "timestamp", "type": "uint256"},
                            {"internalType": "string", "name": "title", "type": "string"},
                            {"internalType": "address", "name": "author", "type": "address"}
                        ],
                        "internalType": "struct LifeExamined.Entry[]",
                        "name": "",
                        "type": "tuple[]"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "totalEntries",
                "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            }
        ];

        let state = {
            entries: [],
            currentEntry: '',
            currentTitle: '',
            selectedEntry: null,
            isConnected: false,
            walletAddress: '',
            searchTerm: '',
            isUploading: false,
            web3: null,
            contract: null
        };

        function updateStatus(message) {
            const statusDiv = document.getElementById('status');
            if (statusDiv) {
                statusDiv.textContent = message;
                console.log(message);
            }
        }

        function checkMetaMask() {
            if (typeof window.ethereum === 'undefined') {
                updateStatus('MetaMask not detected. Please install MetaMask.');
                return false;
            }
            updateStatus('MetaMask detected!');
            return true;
        }

        async function uploadToIPFS(encryptedData) {
            try {
                const ipfsData = {
                    encryptedTitle: encryptedData.encryptedTitle,
                    encryptedContent: encryptedData.encryptedContent,
                    timestamp: new Date().toISOString(),
                    signature: encryptedData.signature,
                    message: encryptedData.message,
                    author: state.walletAddress,
                    version: "1.0"
                };

                console.log('Uploading to IPFS...');
                const mockHash = 'Qm' + Array.from({length: 44}, () => 
                    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'[
                        Math.floor(Math.random() * 62)
                    ]
                ).join('');
                
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                return {
                    IpfsHash: mockHash,
                    PinSize: JSON.stringify(ipfsData).length,
                    Timestamp: new Date().toISOString()
                };

            } catch (error) {
                console.error('IPFS upload failed:', error);
                throw error;
            }
        }

        async function encryptEntry(content, title) {
            try {
                let signature;
                
                if (typeof window.ethereum !== 'undefined' && state.isConnected) {
                    const message = 'Encrypt journal entry: ' + Date.now();
                    signature = await window.ethereum.request({
                        method: 'personal_sign',
                        params: [message, state.walletAddress],
                    });
                } else {
                    signature = '0x' + Array.from({length: 130}, () => 
                        Math.floor(Math.random() * 16).toString(16)
                    ).join('');
                }
                
                const keyData = signature.slice(2, 66);
                
                const encryptText = (text, key) => {
                    let result = '';
                    for (let i = 0; i < text.length; i++) {
                        result += String.fromCharCode(text.charCodeAt(i) ^ key.charCodeAt(i % key.length));
                    }
                    return btoa(result);
                };
                
                const encryptedTitle = encryptText(title, keyData);
                const encryptedContent = encryptText(content, keyData);
                
                return {
                    encryptedTitle,
                    encryptedContent,
                    signature,
                    message: 'Encrypt journal entry: ' + Date.now()
                };
            } catch (error) {
                console.error('Encryption failed:', error);
                throw error;
            }
        }

        async function storeOnBlockchain(ipfsHash, title, timestamp) {
            try {
                if (!state.contract || !state.isConnected) {
                    throw new Error('Wallet not connected or contract not initialized');
                }

                console.log('Preparing blockchain transaction...');

                try {
                    const totalEntries = await state.contract.methods.totalEntries().call();
                    console.log('Contract is accessible. Current total entries:', totalEntries);
                } catch (readError) {
                    console.error('Contract read test failed:', readError);
                    throw new Error('Cannot communicate with smart contract');
                }

                let gasEstimate;
                try {
                    gasEstimate = await state.contract.methods.storeEntry(
                        ipfsHash,
                        timestamp,
                        title
                    ).estimateGas({ from: state.walletAddress });
                    
                    console.log('Gas estimate:', gasEstimate);
                } catch (estimateError) {
                    console.error('Gas estimation failed:', estimateError);
                    gasEstimate = 300000;
                    console.log('Using default gas limit:', gasEstimate);
                }

                const gasPrice = await state.web3.eth.getGasPrice();
                const gasLimit = Math.floor(gasEstimate * 1.2);

                console.log('Sending blockchain transaction...');
                const tx = await state.contract.methods.storeEntry(
                    ipfsHash,
                    timestamp,
                    title
                ).send({
                    from: state.walletAddress,
                    gas: gasLimit,
                    gasPrice: gasPrice
                });
                
                console.log('✅ Real blockchain transaction successful!');
                console.log('Transaction Hash:', tx.transactionHash);
                
                return tx.transactionHash;
                
            } catch (error) {
                console.error('Blockchain transaction failed:', error);
                
                if (error.message.includes('revert')) {
                    throw new Error('Smart contract rejected the transaction. Please check your parameters.');
                } else if (error.message.includes('insufficient funds')) {
                    throw new Error('Insufficient POL for gas fees. Please add more POL to your wallet.');
                } else if (error.code === 4001) {
                    throw new Error('Transaction was cancelled by user.');
                } else {
                    throw new Error('Transaction failed: ' + error.message);
                }
            }
        }

        async function connectWallet() {
            updateStatus('Checking MetaMask...');
            
            if (!checkMetaMask()) {
                return;
            }

            try {
                updateStatus('Requesting account access...');
                const accounts = await window.ethereum.request({ 
                    method: 'eth_requestAccounts' 
                });
                
                if (accounts.length > 0) {
                    updateStatus('Checking network...');
                    
                    const chainId = await window.ethereum.request({ method: 'eth_chainId' });
                    
                    if (chainId !== '0x89') {
                        updateStatus('Switching to Polygon network...');
                        try {
                            await window.ethereum.request({
                                method: 'wallet_switchEthereumChain',
                                params: [{ chainId: '0x89' }],
                            });
                        } catch (switchError) {
                            if (switchError.code === 4902) {
                                updateStatus('Adding Polygon network...');
                                await window.ethereum.request({
                                    method: 'wallet_addEthereumChain',
                                    params: [{
                                        chainId: '0x89',
                                        chainName: 'Polygon Mainnet',
                                        nativeCurrency: {
                                            name: 'POL',
                                            symbol: 'POL',
                                            decimals: 18,
                                        },
                                        rpcUrls: ['https://polygon-rpc.com/'],
                                        blockExplorerUrls: ['https://polygonscan.com/'],
                                    }],
                                });
                            }
                        }
                    }
                    
                    updateStatus('Initializing Web3...');
                    state.web3 = new Web3(window.ethereum);
                    state.contract = new state.web3.eth.Contract(CONTRACT_ABI, CONTRACT_ADDRESS);
                    state.walletAddress = accounts[0];
                    state.isConnected = true;
                    
                    updateStatus('Testing contract connection...');
                    try {
                        const totalEntries = await state.contract.methods.totalEntries().call();
                        console.log('Contract connection successful. Total entries:', totalEntries);
                        updateStatus('Connected successfully!');
                    } catch (contractError) {
                        console.error('Contract connection test failed:', contractError);
                        updateStatus('Warning: Contract may not be accessible');
                    }
                    
                    console.log('✅ Connected to Polygon with real MetaMask!');
                    
                    await loadEntries();
                    renderMainApp();
                    
                    window.ethereum.on('accountsChanged', (accounts) => {
                        if (accounts.length === 0) {
                            state.isConnected = false;
                            state.walletAddress = '';
                            renderWelcomeScreen();
                        } else {
                            state.walletAddress = accounts[0];
                            loadEntries();
                            renderMainApp();
                        }
                    });
                }
            } catch (error) {
                console.error('Error connecting to MetaMask:', error);
                updateStatus('Connection failed: ' + error.message);
            }
        }

        async function loadEntries() {
            try {
                if (state.contract && state.isConnected) {
                    console.log('Loading entries from blockchain...');
                    
                    try {
                        const blockchainEntries = await state.contract.methods.getMyEntries().call({
                            from: state.walletAddress
                        });
                        
                        console.log('Raw blockchain entries:', blockchainEntries);
                        
                        if (blockchainEntries && blockchainEntries.length > 0) {
                            state.entries = blockchainEntries.map((entry, index) => ({
                                id: entry.timestamp + index,
                                title: entry.title || ('Entry ' + new Date(entry.timestamp * 1000).toLocaleDateString()),
                                content: 'Encrypted entry stored on IPFS: ' + entry.ipfsHash,
                                timestamp: new Date(entry.timestamp * 1000).toISOString(),
                                encrypted: true,
                                onChain: true,
                                ipfsHash: entry.ipfsHash,
                                txHash: 'On blockchain'
                            }));
                            
                            console.log('✅ Loaded ' + state.entries.length + ' entries from blockchain');
                        } else {
                            console.log('No entries found on blockchain for this wallet');
                            state.entries = [];
                        }
                    } catch (blockchainError) {
                        console.error('Failed to load from blockchain:', blockchainError);
                        console.log('This might be because you have no entries yet, or there\'s a network issue');
                        state.entries = [];
                    }
                } else {
                    console.log('Contract not ready - will load entries after connection');
                    state.entries = [];
                }
            } catch (error) {
                console.error('Error loading entries:', error);
                state.entries = [];
            }
        }

        async function saveEntry() {
            if (!state.currentTitle.trim() || !state.currentEntry.trim()) {
                alert('Please enter both a title and content for your journal entry.');
                return;
            }
            
            state.isUploading = true;
            renderMainApp();
            
            try {
                console.log('Step 1: Encrypting entry...');
                const encryptedData = await encryptEntry(state.currentEntry, state.currentTitle);
                
                console.log('Step 2: Uploading to IPFS...');
                const ipfsResult = await uploadToIPFS(encryptedData);
                
                console.log('Step 3: Storing on blockchain...');
                const txHash = await storeOnBlockchain(
                    ipfsResult.IpfsHash, 
                    state.currentTitle, 
                    Math.floor(Date.now() / 1000)
                );
                
                console.log('Step 4: Creating entry record...');
                const newEntry = {
                    id: Date.now(),
                    title: state.currentTitle,
                    content: state.currentEntry,
                    timestamp: new Date().toISOString(),
                    encrypted: true,
                    onChain: true,
                    ipfsHash: ipfsResult.IpfsHash,
                    ipfsSize: ipfsResult.PinSize,
                    txHash: txHash
                };
                
                state.entries.unshift(newEntry);
                state.currentEntry = '';
                state.currentTitle = '';
                
                console.log('✅ Entry complete! Encrypted → IPFS → Blockchain');
                console.log('🎉 Your journal entry is now completely decentralized!');
                
                alert('🎉 Journal entry successfully saved to blockchain!');
                
            } catch (error) {
                console.error('Failed to save entry:', error);
                alert('Failed to save entry: ' + error.message);
            } finally {
                state.isUploading = false;
                renderMainApp();
            }
        }

        function viewEntry(entryId) {
            const entry = state.entries.find(e => e.id == entryId);
            if (entry) {
                state.selectedEntry = entry;
                showEntryModal();
            }
        }

        function showEntryModal() {
            if (!state.selectedEntry) return;

            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50';
            
            const modalContent = document.createElement('div');
            modalContent.className = 'bg-white rounded-2xl shadow-xl max-w-2xl w-full max-h-[80vh] overflow-y-auto';
            
            const modalInner = document.createElement('div');
            modalInner.className = 'p-6';
            
            modalInner.innerHTML = 
                '<div class="flex items-center justify-between mb-4">' +
                    '<h2 class="text-2xl font-bold text-gray-900">' + state.selectedEntry.title + '</h2>' +
                    '<button onclick="closeEntryModal()" class="text-gray-400 hover:text-gray-600 text-xl">✕</button>' +
                '</div>' +
                '<div class="flex items-center space-x-4 mb-4 text-sm text-gray-600">' +
                    '<div class="flex items-center space-x-1">' +
                        '<span>📅</span>' +
                        '<span>' + new Date(state.selectedEntry.timestamp).toLocaleString() + '</span>' +
                    '</div>' +
                    '<div class="flex items-center space-x-1">' +
                        '<span>🔒</span>' +
                        '<span>Encrypted</span>' +
                    '</div>' +
                    '<div class="flex items-center space-x-1">' +
                        '<span>⛓️</span>' +
                        '<span>On Blockchain</span>' +
                    '</div>' +
                '</div>' +
                '<div class="prose max-w-none">' +
                    '<div class="bg-yellow-50 border border-yellow-200 rounded-lg p-4 mb-4">' +
                        '<p class="text-sm text-yellow-800">' +
                            '<strong>Note:</strong> This entry is encrypted and stored on IPFS. ' +
                            'To view the actual content, you would need to retrieve and decrypt it from IPFS using your private key.' +
                        '</p>' +
                    '</div>' +
                    '<p class="whitespace-pre-wrap text-gray-700 leading-relaxed">' + state.selectedEntry.content + '</p>' +
                '</div>' +
                '<div class="mt-6 pt-4 border-t border-gray-200">' +
                    '<div class="text-xs text-gray-500 space-y-1">' +
                        '<div><strong>IPFS Hash:</strong> ' + state.selectedEntry.ipfsHash + '</div>' +
                        '<div><strong>Transaction:</strong> ' + state.selectedEntry.txHash + '</div>' +
                        '<div><strong>Entry Size:</strong> ' + (state.selectedEntry.ipfsSize || 'Unknown') + ' bytes</div>' +
                    '</div>' +
                '</div>';

            modalContent.appendChild(modalInner);
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
        }

        function closeEntryModal() {
            const modal = document.querySelector('.fixed.inset-0.bg-black.bg-opacity-50');
            if (modal) {
                modal.remove();
                state.selectedEntry = null;
            }
        }

        function renderWelcomeScreen() {
            const app = document.getElementById('app');
            app.innerHTML = '';
            
            const container = document.createElement('div');
            container.className = 'min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 flex items-center justify-center p-4';
            
            const card = document.createElement('div');
            card.className = 'bg-white rounded-2xl shadow-xl p-8 max-w-md w-full text-center';
            
            const header = document.createElement('div');
            header.className = 'mb-6';
            
            const title = document.createElement('h1');
            title.className = 'text-3xl font-bold text-gray-900 mb-6';
            title.textContent = 'Life Examined';
            
            const button = document.createElement('button');
            button.id = 'connectButton';
            button.className = 'w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-4 rounded-lg transition-colors hover:shadow-lg';
            button.textContent = 'Connect MetaMask to Polygon';
            button.addEventListener('click', connectWallet);
            
            const status = document.createElement('div');
            status.id = 'status';
            status.className = 'mt-4 text-sm text-gray-600';
            
            header.appendChild(title);
            card.appendChild(header);
            card.appendChild(button);
            card.appendChild(status);
            container.appendChild(card);
            app.appendChild(container);
        }

        function renderMainApp() {
            const app = document.getElementById('app');
            app.innerHTML = '';

            const mainContainer = document.createElement('div');
            mainContainer.className = 'min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100';

            // Header
            const header = document.createElement('header');
            header.className = 'bg-white shadow-sm border-b';
            
            const headerContent = document.createElement('div');
            headerContent.className = 'max-w-7xl mx-auto px-4 sm:px-6 lg:px-8';
            
            const headerInner = document.createElement('div');
            headerInner.className = 'flex justify-between items-center py-4';
            
            const titleDiv = document.createElement('div');
            titleDiv.className = 'flex items-center space-x-3';
            
            const headerTitle = document.createElement('h1');
            headerTitle.className = 'text-2xl font-bold text-gray-900';
            headerTitle.textContent = 'Life Examined';
            
            const statusDiv = document.createElement('div');
            statusDiv.className = 'flex items-center space-x-4';
            
            const walletInfo = document.createElement('div');
            walletInfo.className = 'text-sm text-gray-600';
            walletInfo.textContent = 'Connected: ' + state.walletAddress.slice(0, 6) + '...' + state.walletAddress.slice(-4);
            
            const connectionStatus = document.createElement('div');
            connectionStatus.className = 'flex items-center space-x-1 text-green-600 text-sm';
            connectionStatus.innerHTML = '<div class="w-2 h-2 bg-green-500 rounded-full"></div><span>Polygon Connected</span>';
            
            titleDiv.appendChild(headerTitle);
            statusDiv.appendChild(walletInfo);
            statusDiv.appendChild(connectionStatus);
            headerInner.appendChild(titleDiv);
            headerInner.appendChild(statusDiv);
            headerContent.appendChild(headerInner);
            header.appendChild(headerContent);

            // Main content
            const mainContent = document.createElement('div');
            mainContent.className = 'max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8';
            
            const grid = document.createElement('div');
            grid.className = 'grid grid-cols-1 lg:grid-cols-3 gap-8';

            // New entry section
            const newEntrySection = document.createElement('div');
            newEntrySection.className = 'lg:col-span-2';
            
            const newEntryCard = document.createElement('div');
            newEntryCard.className = 'bg-white rounded-2xl shadow-lg p-6';
            
            const newEntryHeader = document.createElement('div');
            newEntryHeader.className = 'flex items-center justify-between mb-6';
            newEntryHeader.innerHTML = '<h2 class="text-xl font-semibold text-gray-900">New Entry</h2><div class="flex items-center space-x-2 text-sm text-gray-500"><span>🔒 Encrypted before blockchain</span></div>';
            
            const formDiv = document.createElement('div');
            formDiv.className = 'space-y-4';
            
            const titleInput = document.createElement('input');
            titleInput.type = 'text';
            titleInput.id = 'titleInput';
            titleInput.placeholder = 'Entry title...';
            titleInput.value = state.currentTitle;
            titleInput.className = 'w-full px-4 py-3 border border-gray-200 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent';
            titleInput.addEventListener('input', (e) => {
                state.currentTitle = e.target.value;
                updateSaveButton();
            });
            
            const contentInput = document.createElement('textarea');
            contentInput.id = 'contentInput';
            contentInput.placeholder = 'Write your thoughts here... Everything you write will be encrypted and stored on Polygon blockchain.';
            contentInput.rows = 12;
            contentInput.value = state.currentEntry;
            contentInput.className = 'w-full px-4 py-3 border border-gray-200 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent resize-none';
            contentInput.addEventListener('input', (e) => {
                state.currentEntry = e.target.value;
                updateSaveButton();
            });
            
            const saveButton = document.createElement('button');
            saveButton.id = 'saveButton';
            saveButton.className = 'flex items-center space-x-2 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-300 text-white font-semibold py-3 px-6 rounded-lg transition-colors';
            const buttonText = state.isUploading ? 'Encrypting → IPFS → Blockchain...' : 'Save to Blockchain';
            saveButton.innerHTML = '<span>➕</span><span>' + buttonText + '</span>';
            saveButton.addEventListener('click', saveEntry);
            
            formDiv.appendChild(titleInput);
            formDiv.appendChild(contentInput);
            formDiv.appendChild(saveButton);
            newEntryCard.appendChild(newEntryHeader);
            newEntryCard.appendChild(formDiv);
            newEntrySection.appendChild(newEntryCard);

            // Entries section
            const entriesSection = document.createElement('div');
            entriesSection.className = 'lg:col-span-1';
            
            const entriesCard = document.createElement('div');
            entriesCard.className = 'bg-white rounded-2xl shadow-lg p-6';
            
            const entriesHeader = document.createElement('div');
            entriesHeader.className = 'flex items-center justify-between mb-4';
            entriesHeader.innerHTML = '<h2 class="text-xl font-semibold text-gray-900">Your Entries</h2><span>📖</span>';
            
            const searchDiv = document.createElement('div');
            searchDiv.className = 'relative mb-4';
            
            const searchInput = document.createElement('input');
            searchInput.type = 'text';
            searchInput.id = 'searchInput';
            searchInput.placeholder = 'Search entries...';
            searchInput.value = state.searchTerm;
            searchInput.className = 'w-full pl-10 pr-4 py-2 border border-gray-200 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent';
            searchInput.addEventListener('input', (e) => {
                state.searchTerm = e.target.value;
                updateEntriesDisplay();
            });
            
            const entriesContainer = document.createElement('div');
            entriesContainer.className = 'space-y-3 max-h-96 overflow-y-auto';
            entriesContainer.id = 'entriesContainer';
            
            searchDiv.appendChild(searchInput);
            entriesCard.appendChild(entriesHeader);
            entriesCard.appendChild(searchDiv);
            entriesCard.appendChild(entriesContainer);
            entriesSection.appendChild(entriesCard);

            grid.appendChild(newEntrySection);
            grid.appendChild(entriesSection);
            mainContent.appendChild(grid);
            mainContainer.appendChild(header);
            mainContainer.appendChild(mainContent);
            app.appendChild(mainContainer);

            updateEntriesDisplay();
            updateSaveButton();
        }

        function updateEntriesDisplay() {
            const entriesContainer = document.getElementById('entriesContainer');
            if (!entriesContainer) return;

            const filteredEntries = state.entries.filter(entry => 
                entry.title.toLowerCase().includes(state.searchTerm.toLowerCase()) ||
                entry.content.toLowerCase().includes(state.searchTerm.toLowerCase())
            );

            entriesContainer.innerHTML = '';

            if (filteredEntries.length === 0) {
                const emptyDiv = document.createElement('div');
                emptyDiv.className = 'text-center py-8 text-gray-500';
                const message = state.searchTerm ? 'No matching entries found.' : 'No entries yet. Start writing!';
                emptyDiv.innerHTML = '<span class="text-4xl">📖</span><p>' + message + '</p>';
                entriesContainer.appendChild(emptyDiv);
            } else {
                filteredEntries.forEach(entry => {
                    const entryDiv = document.createElement('div');
                    entryDiv.className = 'p-4 border border-gray-200 rounded-lg cursor-pointer hover:bg-gray-50 transition-colors';
                    entryDiv.addEventListener('click', () => viewEntry(entry.id));
                    
                    entryDiv.innerHTML = 
                        '<div class="flex items-center justify-between mb-2">' +
                            '<h3 class="font-medium text-gray-900 truncate">' + entry.title + '</h3>' +
                            '<span class="text-green-500">🔒</span>' +
                        '</div>' +
                        '<p class="text-sm text-gray-600 line-clamp-2">' + entry.content + '</p>' +
                        '<div class="flex items-center justify-between mt-2 text-xs text-gray-500">' +
                            '<span>' + new Date(entry.timestamp).toLocaleDateString() + '</span>' +
                            '<span>IPFS: ' + entry.ipfsHash.slice(0, 8) + '...</span>' +
                        '</div>';
                    
                    entriesContainer.appendChild(entryDiv);
                });
            }
        }

        function updateSaveButton() {
            const saveButton = document.getElementById('saveButton');
            if (saveButton) {
                const isDisabled = !state.currentTitle.trim() || !state.currentEntry.trim() || state.isUploading;
                saveButton.disabled = isDisabled;
                if (isDisabled) {
                    saveButton.classList.add('opacity-50', 'cursor-not-allowed');
                } else {
                    saveButton.classList.remove('opacity-50', 'cursor-not-allowed');
                }
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            console.log('Life Examined app initializing...');
            
            if (checkMetaMask()) {
                updateStatus('MetaMask detected! Click to connect.');
            }
            
            renderWelcomeScreen();
        });
    </script>
</body>
</html>
