<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Secure Blockchain Journal</title>
    <script src="https://cdn.jsdelivr.net/npm/buffer@6.0.3/index.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@metamask/eth-sig-util@5.2.0/dist/index.umd.js"></script>
    <script src="https://unpkg.com/ethers@6.13.1/dist/ethers.umd.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
        textarea { width: 100%; height: 100px; }
        button { margin: 5px; padding: 10px; }
        .entry { border: 1px solid #ccc; margin: 10px 0; padding: 10px; }
        #status { color: green; font-weight: bold; }
    </style>
</head>
<body>
    <h1>My Secure Blockchain Journal</h1>
    <p>Connect your MetaMask wallet to start. Entries are encrypted locally and stored on-chain—only you can read them.</p>

    <button id="connectBtn">Connect Wallet</button>
    <div id="status"></div>

    <h2>Add New Entry</h2>
    <textarea id="entryText" placeholder="Write your journal entry here..."></textarea>
    <br>
    <button id="publishBtn" disabled>Encrypt & Publish (1 Tx)</button>

    <h2>Past Entries</h2>
    <button id="loadBtn" disabled>Load My Entries</button>
    <div id="entriesList"></div>

    <script>
        // Config: Paste your deployed contract address here
        const CONTRACT_ADDRESS = '0x8f420B42e119987B9f446C174777Fc35140D8E2e'; // e.g., '0x123...'
        const CHAIN_ID = 137; // Polygon mainnet

        // Contract ABI (simple interface for our Journal contract)
        const ABI = [
            'event EntryAdded(address indexed author, uint256 indexed entryId, bytes ciphertext)',
            'function addEntry(bytes calldata ciphertext) external',
            'function getCounter(address author) external view returns (uint256)'
        ];

        let provider, signer, contract, userAddress, encryptionPublicKey;
        const statusEl = document.getElementById('status');
        const connectBtn = document.getElementById('connectBtn');
        const publishBtn = document.getElementById('publishBtn');
        const loadBtn = document.getElementById('loadBtn');
        const entriesList = document.getElementById('entriesList');

        // Helper to show status messages
        function updateStatus(msg, isError = false) {
            statusEl.textContent = msg;
            statusEl.style.color = isError ? 'red' : 'green';
        }

        // Step 1: Connect wallet (explicit prompt)
        connectBtn.onclick = async () => {
            try {
                if (typeof window.ethereum === 'undefined') {
                    throw new Error('MetaMask not found! Install it.');
                }
                provider = new ethers.BrowserProvider(window.ethereum);
                await provider.send('eth_requestAccounts', []); // Prompts MetaMask
                const network = await provider.getNetwork();
                if (Number(network.chainId) !== CHAIN_ID) {
                    throw new Error(`Switch to Polygon (ID: ${CHAIN_ID}) in MetaMask.`);
                }
                signer = await provider.getSigner();
                userAddress = await signer.getAddress();
                contract = new ethers.Contract(CONTRACT_ADDRESS, ABI, signer);

                // Step 2: Get encryption public key (one-time per session)
                encryptionPublicKey = await provider.send('eth_getEncryptionPublicKey', [userAddress]);

                connectBtn.disabled = true;
                connectBtn.textContent = `Connected: ${userAddress.slice(0, 6)}...`;
                publishBtn.disabled = false;
                loadBtn.disabled = false;
                updateStatus('Wallet connected and encryption key ready!');
            } catch (err) {
                updateStatus(err.message, true);
            }
        };

        // Step 3: Encrypt & Publish (one tx)
        publishBtn.onclick = async () => {
            const text = document.getElementById('entryText').value.trim();
            if (!text) return updateStatus('Enter some text!', true);

            try {
                updateStatus('Encrypting...');
                // Encrypt locally using MetaMask's key (no private key exposed)
                const encrypted = EthSigUtil.encrypt({
                    publicKey: encryptionPublicKey,
                    data: text,
                    version: 'x25519-xsalsa20-poly1305'
                });
                const ciphertext = '0x' + Buffer.from(JSON.stringify(encrypted), 'utf8').toString('hex');

                updateStatus('Publishing to blockchain...');
                const tx = await contract.addEntry(ciphertext);
                await tx.wait();
                document.getElementById('entryText').value = '';
                updateStatus(`Entry #${await contract.getCounter(userAddress)} published! Tx: ${tx.hash}`);
            } catch (err) {
                updateStatus(err.message, true);
            }
        };

        // Step 4: Load past entries (queries blockchain logs)
        loadBtn.onclick = async () => {
            try {
                updateStatus('Loading entries...');
                const topic0 = ethers.id('EntryAdded(address,uint256,bytes)');
                const topic1 = ethers.zeroPadValue(userAddress, 32); // Filter by your address
                const filter = {
                    fromBlock: 0,
                    toBlock: 'latest',
                    address: CONTRACT_ADDRESS,
                    topics: [topic0, topic1]
                };
                const logs = await provider.getLogs(filter);
                logs.reverse(); // Newest first? No, oldest first by block order

                entriesList.innerHTML = '';
                if (logs.length === 0) {
                    entriesList.innerHTML = '<p>No entries yet.</p>';
                    return;
                }

                logs.forEach((log, index) => {
                    const entryId = BigInt(log.topics[1]).toString();
                    const ciphertext = log.data; // Already hex bytes
                    const entryDiv = document.createElement('div');
                    entryDiv.className = 'entry';
                    entryDiv.innerHTML = `
                        <h3>Entry #${entryId}</h3>
                        <button onclick="decryptEntry('${ciphertext}', ${index})">Decrypt (MetaMask Prompt)</button>
                        <div id="decrypted-${index}"></div>
                    `;
                    entriesList.appendChild(entryDiv);
                });
                updateStatus(`${logs.length} entries loaded!`);
            } catch (err) {
                updateStatus(err.message, true);
            }
        };

        // Step 5: Decrypt on demand (single MetaMask prompt)
        window.decryptEntry = async (ciphertext, index) => {
            try {
                const decrypted = await provider.send('eth_decrypt', [ciphertext, userAddress]);
                document.getElementById(`decrypted-${index}`).innerHTML = `<p><strong>Decrypted:</strong> ${decrypted}</p>`;
            } catch (err) {
                updateStatus('Decryption failed—check MetaMask prompt.', true);
            }
        };
    </script>
</body>
</html>
